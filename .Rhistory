mod <- glmmTMB::glmmTMB(formtext, family = beta_family(), data = df, start = start_values)
installed.packages() |> as.data.frame() |> subset(Package=="Matrix", select = c(LibPath, Version))
library(Matrix, lib.loc = "C:/Program Files/R/R-4.3.2/library")
remove.packages("Matrix", lib="C:/Program Files/R/R-4.3.2/library")
detach("package:Matrix", unload = TRUE)
remove.packages("Matrix", lib="C:/Program Files/R/R-4.3.2/library")
install.packages("Matrix")
library(Matrix, lib.loc = "C:/Program Files/R/R-4.3.2/library")
remove.packages("Matrix", lib="C:/Program Files/R/R-4.3.2/library")
library(Matrix)
detach("package:Matrix", unload = TRUE)
library(Matrix)
start_values <- list(theta = c(1, 1))
mod <- glmmTMB::glmmTMB(formtext, family = beta_family(), data = df, start = start_values)
library(glmmTMB)
mod <- glmmTMB::glmmTMB(formtext, family = beta_family(), data = df, start = start_values)
installed.packages() |> as.data.frame() |> subset(Package=="Matrix", select = c(LibPath, Version))
remove.packages("Matrix", lib="C:/Program Files/R/R-4.3.2/library")
library(Matrix, lib.loc = "C:/Program Files/R/R-4.3.2/library")
detach("package:Matrix", unload = TRUE)
library(Matrix)
#You need to install these packages
library(vegan)
library(glmmTMB)#if you get the error negative-loglikelihood
#This are two example data sets from the vegan package
data("varespec")
data("varechem")
#This function performs the analysis you need to run the function to
#store it. Then you can use it
dissbeta <- function(com, env){
dmat     <- function(mat){
lowervals <- lower.tri(diss.mat)
rnames    <- rownames(diss.mat)[row(diss.mat)[lowervals]]
cnames    <- rownames(diss.mat)[col(diss.mat)[lowervals]]
vecvals   <- mat[lowervals]
vectordf  <- data.frame(row_index=rnames, col_index=cnames, vec=vecvals)
return(vectordf)}
diss.mat <- as.data.frame(as.matrix(vegan::vegdist(com)))#Is by default bray-curtis
respondf <- dmat(diss.mat)
depen    <- apply(env, 2, function(x) dmat(as.data.frame(as.matrix(vegan::vegdist(x, method = "euclidean"))))[-c(1:2)])
dependf  <- do.call(cbind.data.frame, depen)
dependf  <- apply(dependf,2,function(x) ifelse(x<=0, log(x+0.01/max(x)), log(x)))
colnames(dependf) <- colnames(env)
df       <- cbind.data.frame(respondf, dependf)
formtext <- as.formula(paste0("vec~", paste0(c(colnames(dependf), "(1|row_index)+(1|col_index)"), collapse = "+")))
mod.sum <- summary(mod <- glmmTMB::glmmTMB(formtext, family = beta_family(), data=df))
n   <- nrow(df)
k   <- ncol(env)
r   <- length(unique(respondf$row_index))+length(unique(respondf$col_index))
dof <- n-(1+k+r)
def <- dof/(nrow(com)-1)
deg <- data.frame(df=dof, n=n, k=k, r=r, original=nrow(com), deflation=def)
adj     <- mod.sum$coefficients$cond
sigma   <- adj[,2]*sqrt(n)
adj[,2] <- sigma/sqrt(nrow(com))
adj[,3] <- adj[,1]/adj[,2]
adj[,4] <- 2*(1-pnorm(abs(adj[,3]), lower.tail = T))
return(list(Estimates=round(mod.sum$coefficients$cond,3),
Adjusted.est=round(adj,3),
Model=mod, Degrees_of_freedom=deg))}
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Fe, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Fe", "Ca", "pH")])
#You need to install these packages
library(vegan)
library(glmmTMB)#if you get the error negative-loglikelihood
#when running the whole code you need to install the Matrix package 1.6-5
#manually from cran
#This are two example data sets from the vegan package
data("varespec")
data("varechem")
#This function performs the analysis you need to run the function to
#store it. Then you can use it
dissbeta <- function(com, env){
dmat     <- function(mat){
lowervals <- lower.tri(diss.mat)
rnames    <- rownames(diss.mat)[row(diss.mat)[lowervals]]
cnames    <- rownames(diss.mat)[col(diss.mat)[lowervals]]
vecvals   <- mat[lowervals]
vectordf  <- data.frame(row_index=rnames, col_index=cnames, vec=vecvals)
return(vectordf)}
diss.mat <- as.data.frame(as.matrix(vegan::vegdist(com)))#Is by default bray-curtis
respondf <- dmat(diss.mat)
depen    <- apply(env, 2, function(x) dmat(as.data.frame(as.matrix(vegan::vegdist(x, method = "euclidean"))))[-c(1:2)])
dependf  <- do.call(cbind.data.frame, depen)
dependf  <- apply(dependf,2,function(x) ifelse(x<=0, log(x+0.01/max(x)), log(x)))
colnames(dependf) <- colnames(env)
df       <- cbind.data.frame(respondf, dependf)
formtext <- as.formula(paste0("vec~", paste0(c(colnames(dependf), "(1|row_index)+(1|col_index)"), collapse = "+")))
mod.sum <- summary(mod <- glmmTMB::glmmTMB(formtext, family = beta_family(), data=df))
n   <- nrow(df)
k   <- ncol(env)
r   <- length(unique(respondf$row_index))+length(unique(respondf$col_index))
dof <- n-(1+k+r)
def <- dof/(nrow(com)-1)
deg <- data.frame(df=dof, n=n, k=k, r=r, original=nrow(com), deflation=def)
adj     <- mod.sum$coefficients$cond
sigma   <- adj[,2]*sqrt(n)
adj[,2] <- sigma/sqrt(nrow(com))
adj[,3] <- adj[,1]/adj[,2]
adj[,4] <- 2*(1-pnorm(abs(adj[,3]), lower.tail = T))
return(list(Estimates=round(mod.sum$coefficients$cond,3),
Adjusted.est=round(adj,3),
Model=mod, Degrees_of_freedom=deg))}
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Fe, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Fe", "Ca", "pH")])
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Fe, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Fe", "Ca", "pH")])
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$row_index))
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Fe, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Fe", "Ca", "pH")])
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Humdepth, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Humdepth", "Ca", "pH")])
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$row_index))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$col_index))
#This function performs the analysis you need to run the function to
#store it. Then you can use it
dissbeta <- function(com, env, scale_factor=0.01){
dmat     <- function(mat){
lowervals <- lower.tri(diss.mat)
rnames    <- rownames(diss.mat)[row(diss.mat)[lowervals]]
cnames    <- rownames(diss.mat)[col(diss.mat)[lowervals]]
vecvals   <- mat[lowervals]
vectordf  <- data.frame(row_index=rnames, col_index=cnames, vec=vecvals)
return(vectordf)}
diss.mat <- as.data.frame(as.matrix(vegan::vegdist(com)))#Is by default bray-curtis
respondf <- dmat(diss.mat)
depen    <- apply(env, 2, function(x) dmat(as.data.frame(as.matrix(vegan::vegdist(x, method = "euclidean"))))[-c(1:2)])
dependf  <- do.call(cbind.data.frame, depen)
dependf  <- apply(dependf,2,function(x) ifelse(x<=0, log(x+0.01/max(x)), log(x)))
colnames(dependf) <- colnames(env)
df       <- cbind.data.frame(respondf, dependf)
formtext <- as.formula(paste0("vec~", paste0(c(colnames(dependf), "(1|row_index)+(1|col_index)"), collapse = "+")))
mod.sum <- summary(mod <- glmmTMB::glmmTMB(formtext, family = beta_family(), data=df))
n   <- nrow(df)
k   <- ncol(env)
r   <- length(unique(respondf$row_index))+length(unique(respondf$col_index))
dof <- n-(1+k+r)
def <- dof/(nrow(com)-1)
deg <- data.frame(df=dof, n=n, k=k, r=r, original=nrow(com), deflation=def)
adj     <- mod.sum$coefficients$cond
sigma   <- adj[,2]*sqrt(n)
adj[,2] <- sigma/sqrt(nrow(com))
adj[,3] <- adj[,1]/adj[,2]
adj[,4] <- 2*(1-pnorm(abs(adj[,3]), lower.tail = T))
return(list(Estimates=round(mod.sum$coefficients$cond,3),
Adjusted.est=round(adj,3),
Model=mod, Degrees_of_freedom=deg))}
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Humdepth, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Humdepth", "Ca", "pH")])
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$row_index))
#You need to install these packages
library(vegan)
library(glmmTMB)#if you get the error negative-loglikelihood
#This are two example data sets from the vegan package
data("varespec")
data("varechem")
#This function performs the analysis you need to run the function to
#store it. Then you can use it
dissbeta <- function(com, env, scale_factor=0.01){
dmat     <- function(mat){
lowervals <- lower.tri(diss.mat)
rnames    <- rownames(diss.mat)[row(diss.mat)[lowervals]]
cnames    <- rownames(diss.mat)[col(diss.mat)[lowervals]]
vecvals   <- mat[lowervals]
vectordf  <- data.frame(row_index=rnames, col_index=cnames, vec=vecvals)
return(vectordf)}
diss.mat <- as.data.frame(as.matrix(vegan::vegdist(com)))#Is by default bray-curtis
respondf <- dmat(diss.mat)
depen    <- apply(env, 2, function(x) dmat(as.data.frame(as.matrix(vegan::vegdist(x, method = "euclidean"))))[-c(1:2)])
dependf  <- do.call(cbind.data.frame, depen)
dependf  <- apply(dependf,2,function(x) ifelse(x<=0, log(x+scale_factor/max(x)), log(x)))
colnames(dependf) <- colnames(env)
df       <- cbind.data.frame(respondf, dependf)
formtext <- as.formula(paste0("vec~", paste0(c(colnames(dependf), "(1|row_index)+(1|col_index)"), collapse = "+")))
mod.sum <- summary(mod <- glmmTMB::glmmTMB(formtext, family = beta_family(), data=df))
n   <- nrow(df)
k   <- ncol(env)
r   <- length(unique(respondf$row_index))+length(unique(respondf$col_index))
dof <- n-(1+k+r)
def <- dof/(nrow(com)-1)
deg <- data.frame(df=dof, n=n, k=k, r=r, original=nrow(com), deflation=def)
adj     <- mod.sum$coefficients$cond
sigma   <- adj[,2]*sqrt(n)
adj[,2] <- sigma/sqrt(nrow(com))
adj[,3] <- adj[,1]/adj[,2]
adj[,4] <- 2*(1-pnorm(abs(adj[,3]), lower.tail = T))
return(list(Estimates=round(mod.sum$coefficients$cond,3),
Adjusted.est=round(adj,3),
Model=mod, Degrees_of_freedom=deg))}
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Humdepth, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Humdepth", "Ca", "pH")])
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$row_index))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$col_index))
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Humdepth, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Humdepth", "Ca", "pH")], scale_factor = 0.1)
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$row_index))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$col_index))
res$Estimates
res$Adjusted.est
barplot(res$Estimates[,1])
barplot(res$Estimates[-1,1])
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Humdepth, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Humdepth", "Ca", "pH")], scale_factor = 0.1)
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$row_index))
plot(res$Model$frame$Humdepth, res$Model$frame$vec,
pch=19, col=as.factor(res$Model$frame$col_index))
dev.off()
barplot(res$Estimates[-1,1])
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec, pch=19)
barplot(res$Estimates[-1,1])
dev.off()
plot(res$Model$frame$Humdepth, res$Model$frame$vec, pch=19, x="log(distance Humdepth)", y="dissimilairity")
#the estimate
#can be interpreted as %change of y given %change in x (e.g., Ca)
#This only accounts exact close to 0. Higher numbers become more and
#more biased at 0.2-0.25 there is a 5-10% difference. In the function below
#select the stressors Humdepth, Ca and pH from the total dataset. I add a
#small constant 0.001/max to  the independent variable if <=0. This is a not done
#of it was the dependent variable.
#run the function
res <- dissbeta(com <- varespec, env <- varechem[c("Humdepth", "Ca", "pH")], scale_factor = 0.1)
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec, pch=19, xlab="log(distance Humdepth)", ylab="dissimilairity")
barplot(res$Estimates[-1,1])
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec, pch=19, xlab="log(distance Humdepth)", ylab="dissimilairity")
barplot(res$Estimates[-1,1], main="regression coefficient as semi-elasticity coefficient")
barplot(res$Estimates[-1,1], main="regression coefficient \nas semi-elasticity coefficient")
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec, pch=19, xlab="log(distance Humdepth)", ylab="dissimilairity")
barplot(res$Estimates[-1,1], main="regression coefficient \nas semi-elasticity coefficient")
#Here I plot the results in the form of a simple scatter-plot
par(mfrow=c(1,2))
plot(res$Model$frame$pH, res$Model$frame$vec, pch=19, xlab="log(distance Humdepth)", ylab="dissimilairity")
#Here I plot the results in the form of a simple scatter-plot
par(mfrow=c(1,2))
plot(res$Model$frame$Humdepth, res$Model$frame$vec, pch=19, xlab="log(distance Humdepth)", ylab="dissimilairity")
barplot(res$Estimates[-1,1], main="Regression coefficient \nas semi-elasticity coefficient")
# Set the path to the folder containing PDF files and the Excel file
pdf_folder <- "C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/"
excel_data <- read_excel("C:/Users/admin/OneDrive/Bureaublad/Paper3/Search2_results.xlsx")
library(readxl)
library(pdftools)
# Set the path to the folder containing PDF files and the Excel file
pdf_folder <- "C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/"
excel_data <- read_excel("C:/Users/admin/OneDrive/Bureaublad/Paper3/Search2_results.xlsx")
list.files(pdf_folder, pattern = "\\.pdf$", full.names = TRUE)
# Set the path to the folder containing PDF files and the Excel file
pdf_folder <- list.files("C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/", pattern = "\\.pdf$", full.names = TRUE)
# Set the path to the folder containing PDF files and the Excel file
pdf_files <- list.files("C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/", pattern = "\\.pdf$", full.names = TRUE)
for(i in pdf_files){}
extract_dois(pdf_files[i])
extract_dois <- function(pdf_path) {
text <- tolower(pdf_text(pdf_path))  # Convert text to lowercase for case-insensitivity
doi_pattern <- "\\b(10\\.\\d{4,}/\\S+)\\b"
dois <- regmatches(text, regexpr(doi_pattern, text, perl = TRUE))
return(dois)}
extract_dois(pdf_files[i])
pdf_files[i]
extract_dois(i)
doinr <- extract_dois(i)
excel_data$DOI == doinr
excel_data$DOI[excel_data$DOI == doinr]
excel_data$DOI[na.omit(excel_data$DOI) == doinr]
excel_data$Paper[na.omit(excel_data$DOI) == doinr]
number <- excel_data$Paper[na.omit(excel_data$DOI) == doinr]
paste(Paper, collapse = "_")
doinr <- extract_dois(i)
number <- excel_data$Paper[na.omit(excel_data$DOI) == doinr]
paste("Paper", collapse = "_")
paste("Paper", number, collapse = "_")
number <- excel_data$Paper[na.omit(excel_data$DOI) == doinr]
paste0("Paper_", number)
1 <- c
1 <- c
c <- 1
for(i in pdf_files){
print(c)
doinr <- extract_dois(i)
number    <- excel_data$Paper[na.omit(excel_data$DOI) == doinr]
papername <- paste0("Paper_", number, ".pdf")
new_pdf_path <- file.path(pdf_folder, papername)
file.rename(pdf_path, new_pdf_path)
c <- c+1
}
print(c)
doinr <- extract_dois(i)
doinr
doinr <- extract_dois(i)[1]
number    <- excel_data$Paper[na.omit(excel_data$DOI) == doinr]
papername <- paste0("Paper_", number, ".pdf")
new_pdf_path <- file.path(pdf_folder, papername)
file.rename(pdf_path, new_pdf_path)
pdf_path
file.rename(i, new_pdf_path)
new_pdf_path
pdf_folder
file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/", papername)
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/rename/", papername)
file.rename(i, new_pdf_path)
papername <- paste0("Paper_", number, ".pdf")
papername
number    <- excel_data$Paper[na.omit(excel_data$DOI) == doinr]
number
doinr <- extract_dois(i)[2]
number    <- excel_data$Paper[na.omit(excel_data$DOI) == doinr]
doinr <- extract_dois(i)
doinr
doinr <- extract_dois(i)[1]
number    <- excel_data$Paper[na.omit(excel_data$DOI) == doinr]
number
c <- 1
for (i in pdf_files) {
print(c)
doinr <- extract_dois(i)[1]
# Use tryCatch to handle potential errors
tryCatch({
number <- excel_data$Paper[na.omit(excel_data$DOI) %in% doinr]
# Check if number is empty
if (length(number) == 0) {
cat("Skipping:", i, "No matching number found.\n")
c <- c + 1
next  # Skip to the next iteration
}
papername <- paste0("Paper_", number, ".pdf")
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/rename/", papername)
file.rename(i, new_pdf_path)
cat("Renamed:", i, "to", new_pdf_path, "\n")
}, error = function(e) {
cat("Error processing:", i, "\n")
})
c <- c + 1
}
doinr <- extract_dois(i)[1]
doinr
excel_data$Paper[na.omit(excel_data$DOI) %in% doinr]
################################################################################
pdf_folder <- "C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/"
extract_dois <- function(pdf_path) {
text <- tolower(pdf_text(pdf_path))  # Convert text to lowercase for case-insensitivity
doi_pattern <- "\\b(10\\.\\d{4,}/\\S+)\\b"
dois <- regmatches(text, regexpr(doi_pattern, text, perl = TRUE))
return(dois)}
# Set the path to the folder containing PDF files and the Excel file
pdf_files <- list.files("C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/", pattern = "\\.pdf$", full.names = TRUE)
excel_data <- read_excel("C:/Users/admin/OneDrive/Bureaublad/Paper3/Search2_results.xlsx")
# Set the path to the folder containing PDF files and the Excel file
pdf_files <- list.files("C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/", pattern = "\\.pdf$", full.names = TRUE)
excel_data <- read_excel("C:/Users/admin/OneDrive/Bureaublad/Paper3/Search2_results.xlsx")
# Set the path to the folder containing PDF files and the Excel file
pdf_files <- list.files("C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/", pattern = "\\.pdf$", full.names = TRUE)
excel_data <- read_excel("C:/Users/admin/OneDrive/Bureaublad/Paper3/Search2_results.xlsx")
doinr <- extract_dois(i)[1]
number <- excel_data$Paper[na.omit(excel_data$DOI) %in% doinr]
number
length(number) == 0
papername <- paste0("Paper_", number, ".pdf")
papername
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/rename/", papername)
file.rename(i, new_pdf_path)
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/rename/", papername)
file.rename(i, new_pdf_path)
new_pdf_path <- file.copy("C:/Users/admin/OneDrive/Bureaublad/rename/", papername)
file.rename(i, new_pdf_path)
file.copy(i, new_pdf_path)
papername <- paste0("Paper_", number, ".pdf")
new_pdf_path <- file.copy("C:/Users/admin/OneDrive/Bureaublad/rename/", papername)
file.copy(i, new_pdf_path)
new_pdf_path <- file.copy("C:/Users/admin/OneDrive/Bureaublad", papername)
new_pdf_path <- file.copy("C:/Users/admin/OneDrive/Bureaublad/rename/", papername)
file.copy(i, new_pdf_path)
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/rename/", papername)
i
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/estz/", papername)
file.rename(i, new_pdf_path)
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/, papername)
file.rename(i, new_pdf_path)
cat("Renamed:", i, "to", new_pdf_path, "\n")
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/", papername)
file.rename(i, new_pdf_path)
################################################################################
library(pdftools)
library(readxl)
pdf_folder <- "C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/"
extract_dois <- function(pdf_path) {
text <- tolower(pdf_text(pdf_path))  # Convert text to lowercase for case-insensitivity
doi_pattern <- "\\b(10\\.\\d{4,}/\\S+)\\b"
dois <- regmatches(text, regexpr(doi_pattern, text, perl = TRUE))
return(dois)}
# Set the path to the folder containing PDF files and the Excel file
pdf_files <- list.files("C:/Users/admin/OneDrive/Bureaublad/Paper3/extz/", pattern = "\\.pdf$", full.names = TRUE)
excel_data <- read_excel("C:/Users/admin/OneDrive/Bureaublad/Paper3/Search2_results.xlsx")
c <- 1
for (i in pdf_files) {
print(c)
doinr <- extract_dois(i)[1]
# Use tryCatch to handle potential errors
tryCatch({
number <- excel_data$Paper[na.omit(excel_data$DOI) %in% doinr]
# Check if number is empty
if (length(number) == 0) {
cat("Skipping:", i, "No matching number found.\n")
c <- c + 1
next  # Skip to the next iteration
}
papername <- paste0("Paper_", number, ".pdf")
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/rename/", papername)
file.rename(i, new_pdf_path)
cat("Renamed:", i, "to", new_pdf_path, "\n")
}, error = function(e) {
cat("Error processing:", i, "\n")
})
c <- c + 1
}
doinr <- extract_dois(i)[1]
number <- excel_data$Paper[na.omit(excel_data$DOI) %in% doinr]
# Check if number is empty
if (length(number) == 0) {
cat("Skipping:", i, "No matching number found.\n")
c <- c + 1
next  # Skip to the next iteration
}
length(number) == 0
papername <- paste0("Paper_", number, ".pdf")
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/rename/", papername)
new_pdf_path
file.rename(i, new_pdf_path)
new_pdf_path
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/Paper3/rename", papername)
file.rename(i, new_pdf_path)
new_pdf_path <- file.path("C:/Users/admin/OneDrive/Bureaublad/rename", papername)
file.rename(i, new_pdf_path)

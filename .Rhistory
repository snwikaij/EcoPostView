plot_list <- vector("list", length(vec_x))
for(i in 1:length(vec_x)){
sub_vec_x               <- vec_x[[i]]
variance_line           <- lapply(1:length(sub_vec_x), function(k)  data.frame(sim=k, x=sub_vec_x[[k]], y=vec_y[[k]]))
variance_line           <- do.call(rbind, variance_line)
colnames(variance_line) <- c("sim", "x", "y")
q  <- 0.5 + c(-1, 1) * interval/2
qx <- quantile(c(expected_line[[i]]$x, variance_line$x), q, na.rm = T)
qy <- quantile(c(expected_line[[i]]$y, variance_line$y), q, na.rm = T)
plot_list[[i]] <- ggplot(variance_line, aes(x, y, group = sim)) +
geom_line(alpha = 0.025, col = "dodgerblue3", lwd = .8)+
geom_line(data=expected_line[[i]], aes(x, y), inherit.aes = FALSE, lwd=0.8) +
xlab(parents[[i]]) +
ylab(response) +
xlim(qx[1], qx[2]) +
ylim(qy[1], qy[2]) +
theme_classic()}
if(length(plot_list)){
return(plot_list)
}else{
plot <- plot_list[[1]]
return(plot)
}}
pred_hyp <- function(object, variable=NULL, input_values,
family="normal",
prior_mu1=NULL, prior_sd1=NULL,
prior_mu0=NULL, prior_sd0=NULL,
level=0.9, seed=666, xlim=NULL){
#Check if all priors are used
if(any(sapply(list(prior_mu1, prior_mu0, prior_sd1, prior_sd0), is.null))){stop("mu and sd for both priors need to be appointed.")}
#Check if all roots are named
if(!all(names(input_values) %in% names(object$Predictions$root))){stop("Not the correct names as input values.")}
set.seed(123)
pred <- ppmn(object$Formula, object$Data, input_values)
#Check if there is only but only variable.
if(is.null(variable)){stop("Select one variable.")}else if(
length(variable)>1){stop("Only one variable allowed.")}
#Check if the variable is in there
pred_var <- names(pred$Predictions$predictions$variance)
if(any(pred_var == variable)==F){stop("Variable name not found.")}
#HDI intervals
hdi_fun              <- function(x, level){
orddata   <- sort(x)
nord      <- length(x)
infomass  <- ceiling(level*nord)
outmass   <- nord-infomass
min_width <- Inf
ll        <- NA
ul        <- NA
for(i in 1:(outmass+1)){
int_width <- orddata[i+infomass-1]-orddata[i]
if(int_width < min_width){
min_width <- int_width
ll <- orddata[i]
ul <- orddata[i+infomass-1]}}
c(ll, ul)}
#Mode or MAP
maxpost              <- function(x){d <- density(x); d$x[which.max(d$y)]}
posterior <- as.numeric(unlist(pred$Predictions$predictions$variance[[variable]]))
posterior <- na.omit(posterior)
post_pred <- c(mean(posterior, na.rm = T), sd(posterior, na.rm = T))
priors_mu <- c(prior_mu1, prior_mu0)
priors_sd <- c(prior_sd1, prior_sd0)
if(family == "normal"){
grid_range <- lapply(1:3, function(i){
mu <- c(post_pred[1], priors_mu)[i]
sd <- c(post_pred[2], priors_sd)[i]
qnorm(c(0.001,0.999), mu, sd)})
seq_min    <-  min(unlist(grid_range), na.rm = T)
seq_max    <-  max(unlist(grid_range), na.rm = T)
grid       <- seq(seq_min, seq_max, length.out=300000)
dens       <- density(posterior)
likelihood <- approx(dens$x, dens$y, rule = 2, xout = grid)$y
prior1     <- dnorm(grid, priors_mu[1], priors_sd[1])
prior2     <- dnorm(grid, priors_mu[2], priors_sd[2])
m1 <- sum(likelihood * prior1)*(grid[2]-grid[1])
m2 <- sum(likelihood * prior2)*(grid[2]-grid[1])
results <-  c(m1/m2, "map"=maxpost(posterior), hdi_fun(posterior, level=level))
xlims   <-  c(seq_min, seq_max)
}else if(family=="gamma"){
grid_range <- lapply(1:3, function(i){
mu <- c(post_pred[1], priors_mu)[i]
sd <- c(post_pred[2], priors_sd)[i]
qgamma(c(0.001,0.999), mu^2/sd^2, mu/sd^2)})
seq_min    <-  min(unlist(grid_range), na.rm = T)
seq_max    <-  max(unlist(grid_range), na.rm = T)
grid       <- seq(seq_min, seq_max, length.out=300000)
dens       <- density(posterior)
likelihood <- approx(dens$x, dens$y, rule = 2, xout = grid)$y
prior1     <- dgamma(grid, priors_mu[1]^2/priors_sd[1]^2, priors_mu[1]/priors_sd[1]^2)
prior2     <- dgamma(grid, priors_mu[2]^2/priors_sd[2]^2, priors_mu[2]/priors_sd[2]^2)
m1 <- sum(likelihood * prior1)*(grid[2]-grid[1])
m2 <- sum(likelihood * prior2)*(grid[2]-grid[1])
results <-  c(m1/m2, "map"=maxpost(posterior), hdi_fun(posterior, level=level))
xlims   <-  c(seq_min, seq_max)
}else if(family=="beta"){
if(any(priors_mu[1] <= 0 | priors_mu[1] >= 1)){stop("When using the familiy beta the priors for mu1 should be >0 or <1.")}
if(any(priors_mu[2] <= 0 | priors_mu[2] >= 1)){stop("When using the familiy beta the priors for mu0 should be >0 or <1.")}
if(any(priors_sd[1] <= 0 | priors_sd[1] >= 1)){stop("When using the familiy beta the priors for sd1 should be >0 or <1.")}
if(any(priors_sd[2] <= 0 | priors_sd[2] >= 1)){stop("When using the familiy beta the priors for sd0 should be >0 or <1.")}
if (priors_sd[1]^2 > priors_mu[1] * (1 - priors_mu[1])){stop("the sd^2 for prior 1 should be <mu*(1−mu)")}
if (priors_sd[2]^2 > priors_mu[2] * (1 - priors_mu[2])){stop("the sd^2 for prior 0 should be <mu*(1−mu)")}
grid_range <- lapply(1:3, function(i){
mu <- c(post_pred[1], priors_mu)[i]
sd <- c(post_pred[2], priors_sd)[i]
phi   <- (mu * (1 - mu) / sd^2) - 1
alpha <- mu * phi
beta  <- (1 - mu) * phi
qbeta(c(0.001,0.999), alpha, beta)})
seq_min    <-  min(unlist(grid_range))
seq_max    <-  max(unlist(grid_range))
grid       <- seq(seq_min, seq_max, length.out=300000)
dens       <- density(posterior)
likelihood <- approx(dens$x, dens$y, rule = 2, xout = grid)$y
phi1   <- (priors_mu[1] * (1 - priors_mu[1]) / priors_sd[1]^2) - 1
phi2   <- (priors_mu[2] * (1 - priors_mu[2]) / priors_sd[2]^2) - 1
prior1     <- dbeta(grid, priors_mu[1]*phi1, (1-priors_mu[1])*phi1)
prior2     <- dbeta(grid, priors_mu[2]*phi2, (1-priors_mu[2])*phi2)
m1 <- sum(likelihood * prior1)*(grid[2]-grid[1])
m2 <- sum(likelihood * prior2)*(grid[2]-grid[1])
results <- c(m1/m2, "map"=maxpost(posterior), hdi_fun(posterior, level=level))
xlims   <- c(seq_min, seq_max)
}else{stop("Not the correct family selected.")}
results        <- c(plogis(log(results[1])), results)
names(results) <- c("P(M1>M0|Data)", "BF10", "predictive map", "ll", "ul")
results        <- round(results, 3)
df <-  data.frame(g=rep(c("Likelihood", "Prior 1", "Prior 0"), each=length(grid)),
x=rep(grid,3),
y=c(likelihood/max(likelihood), prior1/max(prior1), prior2/max(prior2)))
if(is.null(xlim)){xlims <- xlims}else{xlims <- xlim}
like_fig <- suppressWarnings(ggplot(df[df$g != "Posterior",], aes(x,y,group=g,colour = g))+
geom_line()+xlim(xlims)+xlab(variable)+labs(colour = NULL)+
scale_color_manual(breaks = c("Likelihood", "Prior 1", "Prior 0"),
values = c("tomato3", "dodgerblue", "green2"))+
theme_classic()+ylab("Scaled probablility density")+
theme(legend.position = "bottom",
axis.text.y = element_blank(),
axis.ticks.y = element_blank()))
return(list(summary=results, likelihood=like_fig))}
#Fit model plot figure
output  <- ppmn(formula, data, input_values, n_grid = 400, arrow_offset = 6, node_size = 12.5)
output$Plot
#Figure
cascfig <- cascade(object=output, response = "Characeae", interval = .9)
cascfig
post_pred_hyp <- pred_hyp(output, variable = "Characeae", family = "beta",
prior_mu1 = 0.8, prior_sd1 = .1,
prior_mu0 = 0.2, prior_sd0 = .1,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
#Predictive hypothesis
input_values <- list(TP=100, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "Characeae", family = "beta",
prior_mu1 = 0.8, prior_sd1 = .1,
prior_mu0 = 0.2, prior_sd0 = .1,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
input_values
input_values$TP
input_values    <- list(TP = seq(1, 150, length.out=200),
Temp = seq(1, 30, length.out=200))
input_values
cascfig
output$Plot
#Predictive hypothesis
input_values <- list(TP=100)
post_pred_hyp <- pred_hyp(output, variable = "Characeae", family = "beta",
prior_mu1 = 0.8, prior_sd1 = .1,
prior_mu0 = 0.2, prior_sd0 = .1,
input_values = input_values)
#Predictive hypothesis
input_values <- list(TP=100, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "Characeae", family = "beta",
prior_mu1 = 0.8, prior_sd1 = .1,
prior_mu0 = 0.2, prior_sd0 = .1,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
post_pred_hyp <- pred_hyp(output, variable = "CO@", family = "gamma",
prior_mu1 = 80, prior_sd1 = 10,
prior_mu0 = 20, prior_sd0 = 10,
input_values = input_values)
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 80, prior_sd1 = 10,
prior_mu0 = 20, prior_sd0 = 10,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
input_values <- list(TP=20, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 80, prior_sd1 = 10,
prior_mu0 = 20, prior_sd0 = 10,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
input_values <- list(TP=10, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 80, prior_sd1 = 10,
prior_mu0 = 20, prior_sd0 = 10,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
input_values <- list(TP=5, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 80, prior_sd1 = 10,
prior_mu0 = 20, prior_sd0 = 10,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
input_values <- list(TP=5, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 50, prior_sd1 = 10,
prior_mu0 = 10, prior_sd0 = 10,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
input_values <- list(TP=3, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 50, prior_sd1 = 10,
prior_mu0 = 10, prior_sd0 = 10,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 50, prior_sd1 = 20,
prior_mu0 = 10, prior_sd0 = 2.5,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
input_values <- list(TP=1, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 50, prior_sd1 = 20,
prior_mu0 = 10, prior_sd0 = 2.5,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
input_values <- list(TP=.1, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 50, prior_sd1 = 20,
prior_mu0 = 10, prior_sd0 = 2.5,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
post_pred_hyp <- pred_hyp(output, variable = "CO2", family = "gamma",
prior_mu1 = 50, prior_sd1 = 15,
prior_mu0 = 10, prior_sd0 = 2.5,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
input_values <- list(TP=20, Temp=5)
post_pred_hyp <- pred_hyp(output, variable = "HCO3", family = "gamma",
prior_mu1 = 150, prior_sd1 = 50,
prior_mu0 = 25, prior_sd0 = 12.5,
input_values = input_values)
post_pred_hyp$summary
post_pred_hyp$likelihood
df <- array(rnorm(400), ncol=4, nrow=100)
df <- array(rnorm(400), ncol=4, nrow=100)
df <- matrix(rnorm(400), ncol=4, nrow=100)
colnames(df) <- c("B", "A", "C", "I")
df <- matrix(rnorm(400), dim=c(100, 4))
df <- array(rnorm(400), dim=c(100, 4))
colnames(df) <- c("B", "A", "C", "I")
nrow(df)
sample(nrow(df))
sample(ncol(df), 50)
sample(nrow(df), 50)
sample(nrow(df), 50, T)
sample(ncol(df), 50, T)
sample(nrow(df), 50, T)
sample(ncol(df), 50, T)
colnames(df)
df <- array(rnorm(400), dim=c(100, 4))
colnames(df) <- c("B", "A", "C", "I")
nc <- sample(nrow(df), 50, T)
nr <- sample(ncol(df), 50, T)
df[nc, nr]
df <- array(rnorm(400), dim=c(100, 4))
colnames(df) <- c("B", "A", "C", "I")
nc <- sample(nrow(df), 50, T)
nr <- sample(ncol(df), 50, T)
df[nc, nr] <-  NA
df
nc
df[1,4]
df <- array(rnorm(400), dim=c(100, 4))
colnames(df) <- c("B", "A", "C", "I")
nc <- sample(nrow(df), 50, T)
nr <- sample(ncol(df), 50, T)
df[nc, nr] <-  NA
df <- matrix(rnorm(400), ncol=4, nrow=100)
colnames(df) <- c("B", "A", "C", "I")
nc <- sample(nrow(df), 50, T)
nr <- sample(ncol(df), 50, T)
df[nc, nr] <-  NA
View(df)
df <- matrix(rnorm(400), dim=c(100, 4))
colnames(df) <- c("B", "A", "C", "I")
df[sample(length(df), 50)] <- NA
View(df)
df <- matrix(rnorm(400), dim=c(100, 4))
colnames(df) <- c("B", "A", "C", "I")
df <- array(rnorm(400), dim=c(100, 4))
colnames(df) <- c("B", "A", "C", "I")
df[sample(length(df), 50)] <- NA
View(df)
df <- array(rnorm(400), dim=c(100, 4))
colnames(df) <- c("B", "A", "C", "I")
df[sample(length(df), 200)] <- NA
View(df)
df[sample(length(df), 100)] <- NA
#' @importFrom ggplot2 aes
#' @importFrom ggplot2 xlim
#' @importFrom ggplot2 ylim
#' @importFrom ggplot2 geom_histogram
#' @importFrom ggplot2 ggplot_build
#' @importFrom ggplot2 geom_line
#' @importFrom ggplot2 annotate
#' @importFrom ggplot2 scale_alpha
#'
#' @export
extrabc <- function(obj, dist_threshold=NULL, warning=50,
interval=0.9, n_dens=100,
line_position=4.41,
bin_limit=6, bin_width=0.5,
xpos=11, ypos_lim=0.99, alpha_dens=0.3){
#Extract the posterior by threshold distance
priors           <- obj$iterations
seq_val <- seq(0.001, 0.05, 0.001)
seq_df  <- array(NA, dim=c(length(seq_val),2))
for(i in 1:nrow(seq_df)){
seq_set <- priors[priors$distance<seq_val[i],]
if(nrow(seq_set)==0){
acceptance <- 0}else{
acceptance <- nrow(seq_set)/nrow(priors)}
seq_df[i,]       <- c(seq_val[i],acceptance)}
seq_df           <- setNames(as.data.frame(seq_df), c("dist", "acc"))
seq_df           <- na.omit(seq_df)
#Accepted simulations
if(is.null(dist_threshold)){
dy  <- diff(seq_df$acc)/diff(seq_df$dist)
d2y <- diff(dy)/diff(seq_df$dist[-1])
max_curve      <- which.max(abs(d2y))
dist_threshold <- seq_df$dist[max_curve + 1]
accepted         <- which(abs(priors$distance)<dist_threshold)}else{
accepted         <- which(abs(priors$distance)<dist_threshold)}
if(length(accepted)<warning){warning(paste0("The number of accepted prior values is <", warning))}
#Posterior accepted values
posterior        <- priors[accepted,]
#local linear correction function
loc_lm_cor <- function(par, dist){
dfloc <- data.frame(par=par, dist=dist)
p_org   <- predict(mod1 <- lm(par~dist, data=dfloc), type = "response")
wt      <- 1/resid(lm(par~1, data=dfloc))^2
p_wt    <- predict(mod2 <- lm(par~dist, data=dfloc, weights = wt), type = "response")
adjust  <- dfloc$par+p_wt-p_org
org_adj_plot <- rbind(
data.frame(type="Adjusted", x=dfloc$dist, y=adjust),
data.frame(type="Original", x=dfloc$dist, y=dfloc$par))
l <- geom_smooth(method = "glm", formula="y~x", se=F, col='tomato2', lty=2, lwd=1.2)
plot <- ggplot(org_adj_plot, aes(x, y))+
geom_point()+l+
facet_wrap(.~type)+xlab("Distance")+ylab("Posterior iterations")+
theme_classic()
return(list(adjust=adjust, plot=plot))}
#apply loc lm correction to mu, sd and censor
#mu
mu_extracted   <- loc_lm_cor(posterior$mu, posterior$distance)
mu_adj         <- mu_extracted$adjust
mu_plot        <- mu_extracted$plot
#sd
sd_extracted   <- loc_lm_cor(posterior$sd, posterior$distance)
sd_adj         <- sd_extracted$adjust
sd_plot        <- sd_extracted$plot
#cens
cens_extracted <- loc_lm_cor(posterior$cens, posterior$distance)
cens_adj       <- cens_extracted$adjust
cens_plot      <- cens_extracted$plot
#create n_dens density lines
densline <- vector("list", nrow(posterior))
if(!is.list(obj$data_z)){
#Create a density curve for the data
zdens <- data.frame(x=density(obj$data_z, bw=0.2)$x, y=density(obj$data_z, bw=0.2)$y)
zdens <- zdens[zdens$x>0,]}else{mu_data_dens <- vector("list", nrow(posterior))}
#vec for estimated values
est_array <- array(NA, dim=c(nrow(posterior), 5))
for(i in 1:nrow(posterior)){
x        <- obj$simulations[[accepted[i]]]
sim_dens <- density(x, bw=0.1)
dens_df  <- data.frame(i=i, x=sim_dens$x, y=sim_dens$y)
if(is.list(obj$data_z)){
zd        <- obj$data_z[[accepted[i]]]
sim_densz <- density(zd, bw=0.1)
densz_df  <- data.frame(i=i, x=sim_densz$x, y=sim_densz$y)
#set a length  for approximation of density curve
xlen     <- seq(0, 10, length.out=100)
data_val <- approx(densz_df$x, densz_df$y, xout = xlen)$y
mu_data_dens[[i]] <- cbind(xlen, approx(densz_df$x, densz_df$y, xout = xlen)$y)
}else{
#set a length  for approximation of density curve
xlen <- seq(max(c(min(zdens$x), min(dens_df$x))), min(c(max(zdens$x), max(dens_df$x))), length.out=100)
data_val <- approx(zdens$x, zdens$y, xout = xlen)$y}
sim_val  <- approx(dens_df$x, dens_df$y, xout = xlen)$y
est_array[i,]   <- c(cor(data_val, sim_val, use = 'pairwise.complete.obs')^2,
mu_adj[i],
sd_adj[i],
cens_adj[i],
posterior$threshold[i])
densline[[i]] <- dens_df}
#Select n_dens
if(length(densline)<n_dens) n_dens <- length(densline)
#Create a long format
densline <- do.call(rbind, densline[sample(1:length(densline), size=n_dens, replace = F)])
densline <- densline[densline$x>0,]
#create label
mu_stat <- round(colMeans(est_array, na.rm = T),2)
se_stat <- round(apply(est_array, 2, function(x) sd(x, na.rm = T)),2)
n_accept<- nrow(est_array)
lab     <- paste0(c("R-squared=", "mean(Z)=", "sd(Z)=", "Censored=", "Threshold=", "Accepted="), c(mu_stat, n_accept), " (SE=", c(se_stat, NA), ")\n",  collapse = "")
lab     <- sub(" \\(SE=NA\\)(\\n)?$", "", lab)
mean_max <- mean(aggregate(data=densline, y~i, max)[,2])
sd_max   <- sd(aggregate(data=densline, y~i, max)[,2])
catp <- function(x, p) {
if(p == 0){p <- 0.0001}
if(p == 1){p <- 0.9999}
if (is.na(x)) {
return(qnorm(1 - p/2))
} else if (x == "<") { p <- runif(1, 0, p)
} else if (x == ">"){ p <- runif(1, p, 1)}
return(qnorm(1 - p/2))}
if(!is.null(obj$operator)){
z_list <- list()
for(j in 1:1000){
z_vec <- as.data.frame(matrix(NA, ncol = 3, nrow = length(obj$data_p)))
for (i in 1:length(obj$data_p)){
z_vec[i,] <- cbind(obj$operator[i], catp(obj$operator[i], obj$data_p[i]), NA)}
z_vec[,3]   <- cut(as.numeric(z_vec[,2]), seq(0, bin_limit, bin_width))
z_vec       <- as.data.frame(table(z_vec$V3, z_vec$V1))
z_list[[j]] <- z_vec}
long_df           <- do.call(rbind.data.frame, z_list)
colnames(long_df) <- c("bin", "operator", "count")
df_bins           <- aggregate(data=long_df, count~bin+operator, mean)
plhist <- ggplot(df_bins, aes(x = bin, y = count, fill = operator)) +
geom_bar(stat = "identity", col="black", width = 1) + scale_fill_grey(start = 0.85, end = 0.15)+
theme_classic()+xlab("z-value")+geom_vline(xintercept=line_position, lty=2, col="tomato3", lwd=0.8)+
theme(axis.text.x = element_text(hjust=1, angle=45))
#maximum value histogram
max_hist   <- max(ggplot_build(plhist)$data[[1]]$ymax)
#maximum range for histogram
ymax_hist  <- max_hist+max_hist*sd_max
#adjustment factor
adj_factor <- max_hist/mean_max
built <- ggplot_build(plhist)
densline$scale_x <- (densline$x+built$data[[1]]$xmin[1])*mean(abs(built$data[[1]]$xmin-built$data[[1]]$xmax))/bin_width
densline         <-  densline[densline$scale_x < (bin_limit/bin_width),]
plhist <- plhist+geom_line(data=densline, aes(x = scale_x, y = y*adj_factor, group = as.factor(i)), alpha = alpha_dens, color = "grey30", inherit.aes = F)+
ylim(0, ymax_hist)+annotate("text", x = xpos, y = max_hist/2, label = lab)
}else{
plhist <- ggplot(data.frame(z=obj$raw_data), aes(z)) +
geom_histogram(stat = "identity", col="black", binwidth = bin_width, fill="grey70", boundary = 0, closed = "left")+
theme_classic()+xlab("z-value")+geom_vline(xintercept=line_position, lty=2, col="tomato3", lwd=0.8)+
theme(axis.text.x = element_text(hjust=1, angle=45))
#maximum value histogram
max_hist   <- max(ggplot_build(plhist)$data[[2]]$ymax)
#maximum range for histogram
ymax_hist  <- max_hist+max_hist*sd_max
#adjustment factor
adj_factor <- max_hist/mean_max
#final figures
plhist <- plhist+geom_line(data=densline, aes(x = x, y = y*adj_factor, group = as.factor(i)), alpha = alpha_dens, color = "grey30", inherit.aes = F)+
ylim(0, ymax_hist)+annotate("text", x = xpos, y = ymax_hist/2, label = lab)}
if(is.list(obj$data_z)){
zmu <- do.call(rbind, mu_data_dens)
zmu <- aggregate(data=zmu, zmu[,2]~zmu[,1], function(x) mean(x, na.rm=T))
zmu <- setNames(zmu, c("x", "y"))}else{zmu <- zdens}
ylimit <- quantile(densline$y,ypos_lim)
ypos   <- quantile(densline$y,.95)
#Plot the histogram
pldens <- ggplot(densline, aes(x, y, group = as.factor(i)))+xlim(0, 10)+
xlab("z-value")+annotate("text", x = xpos, y = ypos, label = lab)+ylim(0,ylimit)+
geom_vline(xintercept = 1.96, lty=2, lwd=0.6)+
geom_line(data=densline, aes(x = x, y = y,
group = as.factor(i)),
alpha = alpha_dens, color = "grey80", inherit.aes = F)+
geom_line(data=zmu, aes(x, y))+
xlab("z-value") +
ylab("Density") +
theme_classic() +
scale_alpha(guide = 'none')
#Use selected ETI interval level (I specifically choose ETI) due to its simplicity
#Also, I do not know how HDI behaves exactly with limited posterior samples
interval_level              <- 0.5+c(-1,1)*interval/2
#Generate a simple summary
output <- data.frame(
Statistic = c("c", "mu(z)", "sd(z)"),
Mean = round(c(mean(cens_adj), mean(mu_adj), mean(sd_adj)), 4),
SE = round(c(sd(cens_adj), sd(mu_adj), sd(sd_adj)), 4),
ll = round(c(quantile(cens_adj, interval_level[1]),
quantile(mu_adj, interval_level[1]),
quantile(sd_adj, interval_level[1])), 4),
ul = round(c(quantile(cens_adj, interval_level[2]),
quantile(mu_adj, interval_level[2]),
quantile(sd_adj, interval_level[2])), 4))
print(output)
return(invisible(list(summary=output,
distance=seq_df,
density=pldens,
hist=plhist,
posterior=posterior,
check=list(mu_plot, sd_plot, cens_plot))))}

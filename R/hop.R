#' Title
#'
#' @param object An object generated by the mar function
#' @param group The group
#' @param predictor The predictor
#' @param link_function The link function
#' @param nr_hops The number of HOP-lines to be generated
#' @param resolution The resolution of the hop lines
#' @param exponentiate Exponentiation of the predictor gradient
#' @param shift_b0 Shifting the intercept up or down by adding values
#' @param xlimit The limits of the x-axis
#' @param ylimit The limits of tye y-axis
#' @param xlab The x-label text
#'
hop <- function(object, group=NULL, predictor=NULL, link_function=NULL,
                nr_hops=1500, resolution=300, exponentiate=F, shift_b0=0,
                xlimit=c(-5, 10), ylimit=NULL, xlab=NULL){

if(all(!names(object$Estimates) %in% c("b0", "b1")))stop("To create HOP-lines both b0 and b1 are needed E(y|x)=b0+b1x")

#generate warning for limits
if(all(xlimit == c(-5, 10))){warning("xlimit are in default, check if this is appropriate.")}
xl         <- seq(xlimit[1], xlimit[2], length.out=resolution)

#subset the group, predictor and link
b0_df <- object$Estimates$b0
b1_df <- object$Estimates$b1

b0_df <- b0_df[b0_df$group == group & b0_df$link == link_function,]
b1_df <- b1_df[b1_df$group == group & b1_df$predictor == predictor & b1_df$link == link_function,]

#set number of hop lines
minhop <- min(c(nrow(b0_df), nrow(b1_df)))
if(nr_hops>minhop){
  warning(paste("nr_hop can not be larger than", minhop))
  nr_hops <- minhop}

hops_df  <- data.frame(b0=b0_df$estimate, b1=b1_df$estimate)
hops_df  <- hops_df[sample(1:nrow(hops_df), nr_hops, F),]

#one hop line
oneHOP <- function(b0, b1, x, link, j){

  if(link == "identity"){h <- cbind(j, x, y=b0+b1*x)}
  if(link == "log"){h <- cbind(j,  x, y=exp(b0+b1*x))}
  if(link == "logit"){h <- cbind(j, x, y=plogis(b0+b1*x))}

  return(h)}

#generate hop lines
hop_lines <- vector("list", nr_hops)
for(i in 1:nr_hops){hop_lines[[i]] <- oneHOP(hops_df$b0[i]+shift_b0, hops_df$b1[i], xl, link_function, i)}

#all hop lines in data frame format
hops_realized <- as.data.frame(do.call(rbind, hop_lines))
hops_realized$j <- as.factor(hops_realized$j)

#maximum a posteriori value
maxpost <- function(x){d <- density(x); d$x[which.max(d$y)]}

#the expected value
expected <-as.data.frame(oneHOP(maxpost(b0_df$estimate)+shift_b0, maxpost(b1_df$estimate), xl, link_function, 1))

if(exponentiate == T){
hops_realized$x <- exp(hops_realized$x)
expected$x      <- exp(expected$x)}

if(is.null(xlab)){xlab_text <- xlab(predictor)}else{xlab_text <- xlab(xlab)}

if(is.null(ylimit)){
miny <- round(quantile(aggregate(data=hops_realized, y~j, min)[,2], .025))
maxy <- quantile(aggregate(data=hops_realized, y~j, max)[,2], .975)}else{
miny <- ylimit[1]
maxy <- ylimit[2]}

one_plot <- ggplot(hops_realized, aes(x, y, group=as.factor(j)))+
       ylim(miny, maxy)+xlab_text+
       geom_line(lwd=1.2, alpha=0.05, col="grey60")+
       geom_line(data=expected, aes(x, y), lwd=.8, inherit.aes = F)+
       theme_classic()+
       theme(axis.title.y = element_blank(),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                legend.position = "none")

return(one_plot)}


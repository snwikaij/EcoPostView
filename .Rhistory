sub_booty <- booty$wide[unique(c(yep$row, yep$column))]
PerformanceAnalytics::chart.Correlation(sub_booty)
warnings()
chart.Correlation.nostars <- function (R, histogram = TRUE, method = c("pearson", "kendall",
"spearman"), ...)
{
x = checkData(R, method = "matrix")
if (missing(method))
method = method[1]
panel.cor <- function(x, y, digits = 2, prefix = "",
use = "pairwise.complete.obs", method = "pearson",
cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- cor(x, y, use = use, method = method)
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste(prefix, txt, sep = "")
if (missing(cex.cor))
cex <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex * (abs(r) + 0.3)/1.3)
}
hist.panel = function(x, ... = NULL) {
par(new = TRUE)
hist(x, col = "light gray", probability = TRUE,
axes = FALSE, main = "", breaks = "FD")
lines(density(x, na.rm = TRUE), col = "red", lwd = 1)
rug(x)
}
# NEW: linear regression panel
panel.lm <- function(x, y, ...) {
points(x, y, pch = 20, col = rgb(0,0,0,0.4))
abline(lm(y ~ x), col = "red", lwd = 2)
}
if (histogram)
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor,
diag.panel = hist.panel)
else
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor)
}
chart.Correlation.nostars(sub_booty)
chart.Correlation.nostars <- function (R, histogram = TRUE, method = c("pearson", "kendall",
"spearman"), ...)
{
if (missing(method))
method = method[1]
panel.cor <- function(x, y, digits = 2, prefix = "",
use = "pairwise.complete.obs", method = "pearson",
cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- cor(x, y, use = use, method = method)
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste(prefix, txt, sep = "")
if (missing(cex.cor))
cex <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex * (abs(r) + 0.3)/1.3)
}
hist.panel = function(x, ... = NULL) {
par(new = TRUE)
hist(x, col = "light gray", probability = TRUE,
axes = FALSE, main = "", breaks = "FD")
lines(density(x, na.rm = TRUE), col = "red", lwd = 1)
rug(x)
}
# NEW: linear regression panel
panel.lm <- function(x, y, ...) {
points(x, y, pch = 20, col = rgb(0,0,0,0.4))
abline(lm(y ~ x), col = "red", lwd = 2)
}
if (histogram)
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor,
diag.panel = hist.panel)
else
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor)
}
chart.Correlation.nostars(sub_booty)
chart.Correlation.nostars <- function (x, histogram = TRUE, method = c("pearson", "kendall",
"spearman"), ...)
{
if (missing(method))
method = method[1]
panel.cor <- function(x, y, digits = 2, prefix = "",
use = "pairwise.complete.obs", method = "pearson",
cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- cor(x, y, use = use, method = method)
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste(prefix, txt, sep = "")
if (missing(cex.cor))
cex <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex * (abs(r) + 0.3)/1.3)
}
hist.panel = function(x, ... = NULL) {
par(new = TRUE)
hist(x, col = "light gray", probability = TRUE,
axes = FALSE, main = "", breaks = "FD")
lines(density(x, na.rm = TRUE), col = "red", lwd = 1)
rug(x)
}
# NEW: linear regression panel
panel.lm <- function(x, y, ...) {
points(x, y, pch = 20, col = rgb(0,0,0,0.4))
abline(lm(y ~ x), col = "red", lwd = 2)
}
if (histogram)
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor,
diag.panel = hist.panel)
else
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor)
}
chart.Correlation.nostars(sub_booty)
0.3^2
0.36^2
0.31^2
0.32^2
sqrt(0.3)
sqrt(0.1)
yep <- flattenCorrMatrix(cormat)
yep <- yep[abs(yep$cor)>0.3162278,]
sub_booty <- booty$wide[unique(c(yep$row, yep$column))]
chart.Correlation.nostars(sub_booty)
system("git status")
system("git reset --soft HEAD~4")
system("git rm --cached mod.RData")
effdf_single <- read_csv("C:/Users/admin/Downloads/single_effect_sizes_20251205.csv")
library(readr)
effdf_single <- read_csv("C:/Users/admin/Downloads/single_effect_sizes_20251205.csv")
priors <-   EcoPostView::meta(as.numeric(effdf_single$g), as.numeric(effdf_single$se),
get_prior_only = T,
grouping = effdf_single$treatment,
n_thin = 5, n_iter = 35500,
n_burnin = 500)
## Priors for H1
priors$Prior_mu  <- -1.5
priors <-   EcoPostView::meta(as.numeric(effdf_single$g), as.numeric(effdf_single$se),
get_prior_only = T,
grouping = effdf_single$treatment)
## Priors for H1
priors$Prior_mu  <- -1.5
priors$Prior_se  <- 0.75
## Priors for H0
priors$Prior_mu2 <- 0
priors$Prior_se2 <- 0.045
results <- EcoPostView::meta(estimate = as.numeric(effdf_single$g),
stderr = as.numeric(effdf_single$se),
prior_mu = priors[c(2,4)],
prior_mu_se = priors[c(3,5)],
fixed_prior = T,
prior_fam_var = "exp",
interval = .95,
grouping = effdf_single$treatment,
n_thin = 20, n_iter = 10000, n_chain = 8)
## General forest plot
figs <- EcoPostView::forestplot(object=results, study_names=effdf_single$study,
xlab = "Hedges g", xlimit = c(-10, 5))
figs[[5]]
figs[[2]]
## General forest plot
figs <- EcoPostView::forestplot(object=results, study_names=effdf_single$study,
xlab = "Hedges g", xlimit = c(-10, 5))
View(figs)
figs$figures[[5]]
#'
#' @description A forest plot that indicates all priors used in the model, all estimates included and the posterior distribution of the pooled
#' estimate.
#'
#' @importFrom ggplot2 theme
#' @importFrom ggplot2 element_text
#' @importFrom ggplot2 scale_color_grey
#' @importFrom stats quantile
#'
#' @export
forestplot <- function(object, study_names=NULL, interval=0.9,
rel_heights = c(0.25, 0.55, 0.2),
label_x_pos=NULL, label_y_pos=NULL,
xlimit=NULL, xlab="Estimate", label_size=3){
#study names
if(is.null(study_names) || length(object$model$Data$est) != length(study_names)){
study_names <- 1:length(object$model$Data$est)
add_names   <- 0}else{add_names <- 1}
#Create table for all effect-sizes
effdf <- setNames(cbind(as.character(object$model$Data$level), do.call(rbind.data.frame, strsplit(as.character(object$model$Data$level), "_")), study_names, object$model$Data$est,
object$model$Data$se), c("code", "parameter", "predictor", "link", "group", "study", "mu", "se"))
#Calculate z-value for intervals
z        <- qnorm(interval/2+0.5)
#Calculate interval levels
effdf$ll <- as.numeric(effdf$mu)-as.numeric(effdf$se)*z
effdf$ul <- as.numeric(effdf$mu)+as.numeric(effdf$se)*z
#split dataset
split_df <- split(effdf, effdf$code)
#create posterior mcmc objects
post_df  <- split(object$Chains_mu, paste(object$Chains_mu$parameter,object$Chains_mu$predictor,
object$Chains_mu$link, object$Chains_mu$group, sep="_"))
#select only b1
sel_b1 <- which(do.call(rbind.data.frame, lapply(split_df, function(df) unique(df[, 2])))[,1] == "b1")
post_df     <- post_df[sel_b1]
split_df    <- split_df[sel_b1]
split_prior <- object$model$Priors[sel_b1,]
#get the bayesfactors
if(ncol(split_prior)>3){bf_df <- round(get_BF(object)[[1]][,2],2)}
#if names is NULL
if(add_names == 0){
addn <- element_blank()
}else{
addn <- element_text()
}
#x-axis limits
if(is.null(xlimit)){
xlim_pl2 <- NULL
}else{
xlim_pl2 <- xlim(xlimit[1], xlimit[2])
}
#Create all plots
plots <- lapply(1:length(split_df), function(x){
if(!is.null(xlimit)){
split_df[[x]]$ll[split_df[[x]]$ll< xlimit[1]] <- xlimit[1]
split_df[[x]]$ul[split_df[[x]]$ul> xlimit[2]] <- xlimit[2]}
pl2 <- ggplot(split_df[[x]], aes(as.numeric(mu), study))+
geom_point()+geom_vline(xintercept = 0, lty=2, lwd=0.6, col="tomato3")+
geom_errorbarh(data=split_df[[x]], aes(xmin=ll, xmax=ul), width=0)+
theme_classic()+
xlim_pl2+
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
axis.text.y = addn,
axis.text.x = element_blank(),
legend.position = "none")
#get xlims from forest plot
xlims <- ggplot_build(pl2)$layout$panel_params[[1]]$x.range
#generate lines to display priors
prior_df  <- split_prior[x,-1]
mu_seq    <- seq(1, ncol(prior_df)/2, 1)
se_seq    <- seq((ncol(prior_df)/2+1), ncol(prior_df), 1)
x_seq     <- seq(xlims[1], xlims[2] , length.out = 300)
#scale priors to equal height
scaled_prior <- lapply(1:(ncol(prior_df)/2), function(i) {
y <- dnorm(x_seq, as.numeric(prior_df[mu_seq[i]]), as.numeric(prior_df[se_seq[i]]))
data.frame(p=i, x = x_seq, y = y / max(y))})
#generate prior df
prior_df     <- do.call(rbind.data.frame, scaled_prior)
#if only two priors set to H1 H0
if (length(unique(prior_df$p)) == 2) {
map <- c(`1` = "H1", `2` = "H0")
p_chr <- as.character(prior_df$p)
idx <- p_chr %in% names(map)
p_chr[idx] <- map[p_chr[idx]]
prior_df$p <- p_chr
prior_df$p <- factor(prior_df$p, levels = c("H1", "H0"))
}else{
p_chr <- as.character(prior_df$p)
nums <- sort(unique(p_chr))
map <- setNames(paste0("Mod", nums), nums)
prior_df$p <- map[p_chr]
}
#plot priors
pl3 <- ggplot(prior_df, aes(x, y, group=p, col=as.factor(p)))+
geom_line()+labs(col="Prior")+ggplot2::scale_color_grey(start = 0.85, end = 0.15)+
geom_vline(xintercept = 0, lty=2, lwd=0.6, col="tomato3")+
theme_classic()+
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
axis.text.x = element_blank(),
axis.text.y = element_blank(),
legend.position = "top")
if (ncol(object$model$Priors[x, -1]) > 3) {
text <- paste0(
"mu=", round(object$Summary[x,"mu"], 2), " ",
"se=", round(object$Summary[x,"se"], 2), "\n",
"ll=", round(object$Summary[x,"ll"], 2), " ",
"ul=", round(object$Summary[x,"ul"], 2), " ",
"I2=", round(object$Summary[x,"I2"], 2), "\n",
"BF=", bf_df[x]
)} else {
text <- paste0(
"mu=", round(object$Summary[x,"mu"], 2), " ",
"se=", round(object$Summary[x,"se"], 2), "\n",
"ll=", round(object$Summary[x,"ll"], 2), " ",
"ul=", round(object$Summary[x,"ul"], 2), " ",
"I2=", round(object$Summary[x,"I2"], 2)*100,"%")}
post_bar <- object$Summary[x,c("ll", "ul")]
if(post_bar$ll<xlims[1]){post_bar$ll <- xlims[1]}
if(post_bar$ul>xlims[2]){post_bar$ul <- xlims[2]}
pl1 <- ggplot(post_df[[x]], aes(estimate, group=group))+
xlim(c(xlims[1], xlims[2]))+
geom_point(data=object$Summary[x,], aes(x=mu, y=0), inherit.aes = F)+
geom_errorbarh(data=post_bar, aes(xmin=ll, xmax=ul, y=0), width=0, inherit.aes = F)+
geom_vline(xintercept = 0, lty=2, lwd=0.6, col="tomato3")+
geom_density()+xlab(xlab)+
theme_classic()+
theme(axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.line.y = element_blank(),
axis.ticks.y = element_blank(),
legend.position = "none")
if(is.null(label_y_pos)){ylim_lab <- ggplot_build(pl1)$layout$panel_params[[1]]$y.range[2]/1.5
}else{ylim_lab <- ggplot_build(pl1)$layout$panel_params[[1]]$y.range[2]*label_y_pos}
if(is.null(label_x_pos)){xlim_lab <- ifelse(sign(xlims[1])==-1,xlims[1]+diff(xlims)*0.1,xlims[1]-diff(xlims)*0.1)
}else{xlim_lab <-  label_x_pos}
pl1 <- pl1+annotate("text", x = xlim_lab,
y = ylim_lab, label = text,
size = label_size)
cowplot::plot_grid(pl3, pl2, pl1, ncol=1, rel_heights = rel_heights, align = "v")
})
return(list(figures=plots, data=split_df))}
## General forest plot
figs <- forestplot(object=results, study_names=effdf_single$study,
xlab = "Hedges g", xlimit = c(-10, 5))
library(EcoPostView)
## General forest plot
figs <- forestplot(object=results, study_names=effdf_single$study,
xlab = "Hedges g", xlimit = c(-10, 5))
#'
#' @description A forest plot that indicates all priors used in the model, all estimates included and the posterior distribution of the pooled
#' estimate.
#'
#' @importFrom ggplot2 theme
#' @importFrom ggplot2 element_text
#' @importFrom ggplot2 scale_color_grey
#' @importFrom stats quantile
#'
#' @export
forestplot <- function(object, study_names=NULL, interval=0.9,
rel_heights = c(0.25, 0.55, 0.2),
label_x_pos=NULL, label_y_pos=NULL,
xlimit=NULL, xlab="Estimate", label_size=3){
#study names
if(is.null(study_names) || length(object$model$Data$est) != length(study_names)){
study_names <- 1:length(object$model$Data$est)
add_names   <- 0}else{add_names <- 1}
#Create table for all effect-sizes
effdf <- setNames(cbind(as.character(object$model$Data$level), do.call(rbind.data.frame, strsplit(as.character(object$model$Data$level), "_")), study_names, object$model$Data$est,
object$model$Data$se), c("code", "parameter", "predictor", "link", "group", "study", "mu", "se"))
#Calculate z-value for intervals
z        <- qnorm(interval/2+0.5)
#Calculate interval levels
effdf$ll <- as.numeric(effdf$mu)-as.numeric(effdf$se)*z
effdf$ul <- as.numeric(effdf$mu)+as.numeric(effdf$se)*z
#split dataset
split_df <- split(effdf, effdf$code)
#create posterior mcmc objects
post_df  <- split(object$Chains_mu, paste(object$Chains_mu$parameter,object$Chains_mu$predictor,
object$Chains_mu$link, object$Chains_mu$group, sep="_"))
#select only b1
sel_b1 <- which(do.call(rbind.data.frame, lapply(split_df, function(df) unique(df[, 2])))[,1] == "b1")
post_df     <- post_df[sel_b1]
split_df    <- split_df[sel_b1]
split_prior <- object$model$Priors[sel_b1,]
#get the bayesfactors
if(ncol(split_prior)>3){bf_df <- round(get_BF(object)[[1]][,2],2)}
#if names is NULL
if(add_names == 0){
addn <- ggplot2::element_blank()
}else{
addn <- ggplot2::element_text()
}
#x-axis limits
if(is.null(xlimit)){
xlim_pl2 <- NULL
}else{
xlim_pl2 <- xlim(xlimit[1], xlimit[2])
}
#Create all plots
plots <- lapply(1:length(split_df), function(x){
if(!is.null(xlimit)){
split_df[[x]]$ll[split_df[[x]]$ll< xlimit[1]] <- xlimit[1]
split_df[[x]]$ul[split_df[[x]]$ul> xlimit[2]] <- xlimit[2]}
pl2 <- ggplot(split_df[[x]], aes(as.numeric(mu), study))+
geom_point()+geom_vline(xintercept = 0, lty=2, lwd=0.6, col="tomato3")+
geom_errorbarh(data=split_df[[x]], aes(xmin=ll, xmax=ul), width=0)+
theme_classic()+
xlim_pl2+
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
axis.text.y = addn,
axis.text.x = element_blank(),
legend.position = "none")
#get xlims from forest plot
xlims <- ggplot_build(pl2)$layout$panel_params[[1]]$x.range
#generate lines to display priors
prior_df  <- split_prior[x,-1]
mu_seq    <- seq(1, ncol(prior_df)/2, 1)
se_seq    <- seq((ncol(prior_df)/2+1), ncol(prior_df), 1)
x_seq     <- seq(xlims[1], xlims[2] , length.out = 300)
#scale priors to equal height
scaled_prior <- lapply(1:(ncol(prior_df)/2), function(i) {
y <- dnorm(x_seq, as.numeric(prior_df[mu_seq[i]]), as.numeric(prior_df[se_seq[i]]))
data.frame(p=i, x = x_seq, y = y / max(y))})
#generate prior df
prior_df     <- do.call(rbind.data.frame, scaled_prior)
#if only two priors set to H1 H0
if (length(unique(prior_df$p)) == 2) {
map <- c(`1` = "H1", `2` = "H0")
p_chr <- as.character(prior_df$p)
idx <- p_chr %in% names(map)
p_chr[idx] <- map[p_chr[idx]]
prior_df$p <- p_chr
prior_df$p <- factor(prior_df$p, levels = c("H1", "H0"))
}else{
p_chr <- as.character(prior_df$p)
nums <- sort(unique(p_chr))
map <- setNames(paste0("Mod", nums), nums)
prior_df$p <- map[p_chr]
}
#plot priors
pl3 <- ggplot(prior_df, aes(x, y, group=p, col=as.factor(p)))+
geom_line()+labs(col="Prior")+ggplot2::scale_color_grey(start = 0.85, end = 0.15)+
geom_vline(xintercept = 0, lty=2, lwd=0.6, col="tomato3")+
theme_classic()+
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
axis.text.x = element_blank(),
axis.text.y = element_blank(),
legend.position = "top")
if (ncol(object$model$Priors[x, -1]) > 3) {
text <- paste0(
"mu=", round(object$Summary[x,"mu"], 2), " ",
"se=", round(object$Summary[x,"se"], 2), "\n",
"ll=", round(object$Summary[x,"ll"], 2), " ",
"ul=", round(object$Summary[x,"ul"], 2), " ",
"I2=", round(object$Summary[x,"I2"], 2), "\n",
"BF=", bf_df[x]
)} else {
text <- paste0(
"mu=", round(object$Summary[x,"mu"], 2), " ",
"se=", round(object$Summary[x,"se"], 2), "\n",
"ll=", round(object$Summary[x,"ll"], 2), " ",
"ul=", round(object$Summary[x,"ul"], 2), " ",
"I2=", round(object$Summary[x,"I2"], 2)*100,"%")}
post_bar <- object$Summary[x,c("ll", "ul")]
if(post_bar$ll<xlims[1]){post_bar$ll <- xlims[1]}
if(post_bar$ul>xlims[2]){post_bar$ul <- xlims[2]}
pl1 <- ggplot(post_df[[x]], aes(estimate, group=group))+
xlim(c(xlims[1], xlims[2]))+
geom_point(data=object$Summary[x,], aes(x=mu, y=0), inherit.aes = F)+
geom_errorbarh(data=post_bar, aes(xmin=ll, xmax=ul, y=0), width=0, inherit.aes = F)+
geom_vline(xintercept = 0, lty=2, lwd=0.6, col="tomato3")+
geom_density()+xlab(xlab)+
theme_classic()+
theme(axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.line.y = element_blank(),
axis.ticks.y = element_blank(),
legend.position = "none")
if(is.null(label_y_pos)){ylim_lab <- ggplot_build(pl1)$layout$panel_params[[1]]$y.range[2]/1.5
}else{ylim_lab <- ggplot_build(pl1)$layout$panel_params[[1]]$y.range[2]*label_y_pos}
if(is.null(label_x_pos)){xlim_lab <- ifelse(sign(xlims[1])==-1,xlims[1]+diff(xlims)*0.1,xlims[1]-diff(xlims)*0.1)
}else{xlim_lab <-  label_x_pos}
pl1 <- pl1+annotate("text", x = xlim_lab,
y = ylim_lab, label = text,
size = label_size)
cowplot::plot_grid(pl3, pl2, pl1, ncol=1, rel_heights = rel_heights, align = "v")
})
return(list(figures=plots, data=split_df))}
library(ggplot2)
## General forest plot
figs <- forestplot(object=results, study_names=effdf_single$study,
xlab = "Hedges g", xlimit = c(-10, 5))
figs$figures[[5]]
## General forest plot
figs <- forestplot(object=results, study_names=effdf_single$study,
xlab = "Hedges g", xlimit = c(-10, 5))
figs$figures[[5]]
effdf_single <- read_csv("C:/Users/admin/Downloads/single_effect_sizes_20251205.csv")
priors <-   EcoPostView::meta(as.numeric(effdf_single$g), as.numeric(effdf_single$se),
get_prior_only = T,
grouping = effdf_single$treatment)
# Cohen's d to CLES assuming CLES at 95% around 0.45-0.55 is just noise (H0)
# pnorm(0.0445*2 / sqrt(2))
# Define priors based on other studies for (H1)
# dprior <- read_excel("C:/Users/admin/OneDrive/Bureaublad/RESIST/Data/Book1.xlsx")
# Exclude some unreasonable deemed outliers
# d <- dprior$d[dprior$d<0.5]
# d <- d[d>-3.5]
# Plot histogram and density to asses prior for H1
# p1 <- ggplot(data.frame(d=d), aes(x=d))+
# geom_histogram(fill="white", col="black")
# p2 <- ggplot(data.frame(d=d), aes(x=d))+
# geom_density(fill="white", col="black")
# cowplot::plot_grid(p1, p2)
# prior mean for H1 is around -1.5 and SD is around 0.75
# c("mean"=mean(d), "SD"=sd(d))
## Priors for H1
priors$Prior_mu  <- -1.5
priors$Prior_se  <- 0.75
## Priors for H0
priors$Prior_mu2 <- 0
priors$Prior_se2 <- 0.045
results <- EcoPostView::meta(estimate = as.numeric(effdf_single$g),
stderr = as.numeric(effdf_single$se),
prior_mu = priors[c(2,4)],
prior_mu_se = priors[c(3,5)],
fixed_prior = T,
prior_fam_var = "exp",
interval = .95,
grouping = effdf_single$treatment,
n_thin = 20, n_iter = 10000, n_chain = 8)
## General forest plot
figs <- forestplot(object=results, study_names=effdf_single$study,
xlab = "Hedges g", xlimit = c(-10, 5))
figs$figures[[5]]

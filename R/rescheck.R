#' Residual check
#'
#' @param object An object generated by the meta function
#' @param order_predictor The order of the predictors
#' @param order_group The order of the groups
#' @param xlimit the upper quantile limit of 1/se or 1/n
#' @param ylimit The quantile limits residuals displayed in the figures
#' @param b0_out Display the intercept in the residuals, by default False
#'
#' @description
#' This function can be used to asses the bias of the model output. It is a visual ('eye balling') check
#' for the distribution of the residuals. The residuals should be approximately 'randomly' distributed around 0 (origin) at the y-axis
#' relative to the inverse of the sample size (1/n) or inverse of the standard error (1/se). It is akin to classical funnel plots
#' If bias is clear a diagonal pattern would become visible the dashed red line would than not fall directly over the blue line.
#'
#' @export
rescheck <- function(object, order_predictor = NULL, order_group = NULL,
                     xlimit=0.9999, ylimit=c(0.025, 0.975), b0_out=T){

#extract levels
levels <- setNames(do.call(rbind.data.frame, strsplit(as.character(object$model$Data$level), "_")), c("parameter", "predictor", "link_function", "group"))

#If sample size is included
if(!is.null(object$model$Data$Nsamp)){
  df_resid  <- data.frame(resid=object$Residuals, n=object$model$Data$Nsamp, se=object$model$Data$se, levels)}else{
  df_resid  <- data.frame(resid=object$Residuals, se=object$model$Data$se, levels)}

#Only display residuals for b1 and do not include b0
if(b0_out==T){
df_resid                                       <- df_resid[df_resid$parameter != "b0",]}else{
df_resid$predictor[df_resid$predictor == "NA"] <- "b0 (Intercept)"
order_predictor                                <- c(order_predictor, "b0 (Intercept)")}

#order per group and predictor
if(!is.null(order_group)&&!is.null(order_group)){
  df_resid$group     <- factor(df_resid$group, levels = order_group)
  df_resid$predictor <- factor(df_resid$predictor, levels = order_predictor)
  df_resid           <- df_resid[order(df_resid$group, df_resid$predictor),]
}else if(!is.null(order_group)&&is.null(order_predictor)){
  df_resid$group     <- factor(df_resid$group, levels = order_group)
  df_resid$predictor <- factor(df_resid$predictor, levels = levels(df_resid$predictor))
  df_resid           <- df_resid[order(df_resid$group),]
}else if(!is.null(order_predictor)&&is.null(order_group)){
  df_resid$group     <- factor(df_resid$group, levels = levels(df_resid$group))
  df_resid$predictor <- factor(df_resid$predictor, levels = order_predictor)
  df_resid           <- df_resid[order(df_resid$predictor),]
}else{
  df_resid$group     <- factor(df_resid$group, levels = unique(df_resid$group))
  df_resid$predictor <- factor(df_resid$predictor, levels = unique(df_resid$predictor))
  df_resid           <- df_resid[order(df_resid$group, df_resid$predictor),]}

#Set limits for the base  plots
ylim_plot <- quantile(df_resid$resid, c(ylimit[1], ylimit[2]))
xlim_plot <- c(0, quantile(df_resid$resid, xlimit))

#If number of samples is used
if(!is.null(object$model$Data$Nsamp)){

#Plot interval bounds for sample size for all samples
plot_1_1 <- ggplot(df_resid, aes(1/n, resid))+xlab("Inverse sample size (1/n)")+ylab("Posterior mean model residuals")+
    geom_point(alpha=0.3, col="grey20")+xlim(0, 0.2)+ylim(ylim_plot[1], ylim_plot[2])+
    #geom_line(data=bounds, aes(x=n_vals, y=n_bounds, group=g), inherit.aes = F, col="dodgerblue2", lty=2, lwd=1.2)+
    geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
    geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
    theme_classic()+
    theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

#Plot interval bounds for sample size per group
plot_1_2 <- ggplot(df_resid, aes(1/n, resid))+xlab("Inverse sample size (1/n)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+xlim(0, 0.2)+ylim(ylim_plot[1], ylim_plot[2])+
  #geom_line(data=bounds, aes(x=n_vals, y=n_bounds, group=g), inherit.aes = F, col="dodgerblue2", lty=2, lwd=1.2)+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  facet_wrap(.~group)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

#Plot interval bounds for sample size per predictor
plot_1_3 <- ggplot(df_resid, aes(1/n, resid))+xlab("Inverse sample size (1/n)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+xlim(0, 0.2)+ylim(ylim_plot[1], ylim_plot[2])+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  facet_wrap(.~predictor)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))}

plot_2_1 <- ggplot(df_resid, aes(1/se, resid))+xlab("Inverse standard error (1/se)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+
  xlim(0, xlim_plot[2])+ylim(ylim_plot[1], ylim_plot[2])+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

plot_2_2 <- ggplot(df_resid, aes(1/se, resid))+xlab("Inverse standard error (1/se)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+
  xlim(0, xlim_plot[2])+ylim(ylim_plot[1], ylim_plot[2])+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  facet_wrap(.~group)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

plot_2_3 <- ggplot(df_resid, aes(1/se, resid))+xlab("Inverse standard error (1/se)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+
  xlim(0, xlim_plot[2])+ylim(ylim_plot[1], ylim_plot[2])+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  facet_wrap(.~predictor)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

#If sample size is included include all figs als with bias_n
if(!is.null(object$model$Data$Nsamp)){
  total <- list(bias_n=plot_1_1, bias_se=plot_2_1,
                bias_n_group=plot_1_2, bias_se_group=plot_2_2,
                bias_n_predictor=plot_1_3, bias_se_predictor=plot_2_3)}else{
  total <- list(bias_se=plot_2_1,
                bias_se_group=plot_2_2,
                bias_se_predictor=plot_2_3)}
return(total)}


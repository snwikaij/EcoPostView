store_params[which(distance < quantile(distance, .025))]
which(distance < quantile(distance, .025))
store_params[[which(distance < quantile(distance, .025))]]
store_params[which(distance < quantile(distance, .025))]
store_params[5]
store_params[[5]]
unlist(store_params[which(distance < quantile(distance, .025))])
hist(unlist(store_params[which(distance < quantile(distance, .025))]))
accepted <- store_params[which(distance < quantile(distance, .025))]
accepted[[1]]
extract_param_df <- function(accepted) {
out <- lapply(seq_along(accepted), function(i) {
sample_i <- accepted[[i]]
# each node is sample_i$Chl, sample_i$DOC, etc.
nodes <- names(sample_i)
# for each node extract b0, b1, ...
node_df <- do.call(rbind, lapply(nodes, function(node) {
params <- sample_i[[node]][[1]]         # numeric vector with names b0, b1, ...
data.frame(
variable  = node,
parameter = names(params),
value     = as.numeric(params),
iter      = i
)
}))
node_df
})
do.call(rbind, out)
}
extract_param_df(accepted)
accepted <- extract_param_df(accepted)
tidyr::spread(accepted)
paste0(accepted$variable, "_", accepted$parameter)
paste0(accepted$variable, "_", accepted$parameter)
paste0(accepted$variable, "_", accepted$parameter)
accepted$unique <- paste0(accepted$variable, "_", accepted$parameter)
spread(accepted, "unique")
tidyr::spread(accepted, "unique")
head(accepted)
accepted_wide <- tidyr::spread(
data  = accepted[, c("iter", "unique", "value")],
key   = unique,
value = value
)
accepted_wide
PerformanceAnalytics::chart.Correlation(accepted_wide)
accepted <- store_params[which(distance < quantile(distance, .01))]
accepted <- extract_param_df(accepted)
accepted$unique <- paste0(accepted$variable, "_", accepted$parameter)
accepted_wide <- tidyr::spread(
data  = accepted[, c("iter", "unique", "value")],
key   = unique,
value = value
)
PerformanceAnalytics::chart.Correlation(accepted_wide)
bootstrap_ppmn <- function(object, new_data, nsim = 10000, quantile=0.01, interval_type = "CI") {
preds        <- vector("list", nsim)
bootstrap    <- vector("list", nsim)
distance     <- vector("numeric", nsim)
store_params <- vector("list", nsim)
for (b in 1:nsim) {
boot_data        <- new_data[sample(nrow(new_data), replace = TRUE), ]
preds            <- predict_ppmn(object, boot_data, nsim = 1, interval_type = interval_type)
rmse_df          <- preds$Data-do.call(cbind, lapply(preds$Variance[which(!names(preds$Variance) %in% preds$Roots)], function(x) x[[1]]))
distance[b]      <- sum(rowSums(log(abs(rmse_df)), na.rm=T), na.rm = T)
store_params[[b]]<- preds$Parameters}
accepted <- store_params[which(distance < quantile(distance, quantile))]
extract_param_df <- function(accepted) {
out <- lapply(seq_along(accepted), function(i) {
sample_i <- accepted[[i]]
# each node is sample_i$Chl, sample_i$DOC, etc.
nodes <- names(sample_i)
# for each node extract b0, b1, ...
node_df <- do.call(rbind, lapply(nodes, function(node) {
params <- sample_i[[node]][[1]]         # numeric vector with names b0, b1, ...
data.frame(
variable  = node,
parameter = names(params),
value     = as.numeric(params),
iter      = i
)
}))
node_df
})
do.call(rbind, out)
}
accepted <- extract_param_df(accepted)
accepted$unique <- paste0(accepted$variable, "_", accepted$parameter)
accepted_wide <- tidyr::spread(
data  = accepted[, c("iter", "unique", "value")],
key   = unique,
value = value)
return(long=accepted, wide=accepted_wide)}
test_df <- read_excel("C:/Users/admin/OneDrive/Bureaublad/PPMN/Test dataset/Test.xlsx")
colnames(test_df)[8:ncol(test_df)] <- c("Chl", "DOC", "pH", "TP", "EC", "Temp",  "DO", "Alk", "HCO3", "Macrophytes")
test_df <- test_df[!is.na(test_df$TP) | !is.na(test_df$Temp),]
test_df <- test_df[!test_df$Study %in% c(
"Environmental variables associated with littoral macroinvertebrate community composition in Arctic lakes",
"Surface Water Quality Data Maziba Catchment, Western Uganda (1.1) [Data set]"),]
booty <- bootstrap_ppmn(dag_model, test_df, nsim = 30000)
bootstrap_ppmn <- function(object, new_data, nsim = 10000, quantile=0.01, interval_type = "CI") {
preds        <- vector("list", nsim)
bootstrap    <- vector("list", nsim)
distance     <- vector("numeric", nsim)
store_params <- vector("list", nsim)
for (b in 1:nsim) {
print(b)
boot_data        <- new_data[sample(nrow(new_data), replace = TRUE), ]
preds            <- predict_ppmn(object, boot_data, nsim = 1, interval_type = interval_type)
rmse_df          <- preds$Data-do.call(cbind, lapply(preds$Variance[which(!names(preds$Variance) %in% preds$Roots)], function(x) x[[1]]))
distance[b]      <- sum(rowSums(log(abs(rmse_df)), na.rm=T), na.rm = T)
store_params[[b]]<- preds$Parameters}
accepted <- store_params[which(distance < quantile(distance, quantile))]
extract_param_df <- function(accepted) {
out <- lapply(seq_along(accepted), function(i) {
sample_i <- accepted[[i]]
# each node is sample_i$Chl, sample_i$DOC, etc.
nodes <- names(sample_i)
# for each node extract b0, b1, ...
node_df <- do.call(rbind, lapply(nodes, function(node) {
params <- sample_i[[node]][[1]]         # numeric vector with names b0, b1, ...
data.frame(
variable  = node,
parameter = names(params),
value     = as.numeric(params),
iter      = i
)
}))
node_df
})
do.call(rbind, out)
}
accepted <- extract_param_df(accepted)
accepted$unique <- paste0(accepted$variable, "_", accepted$parameter)
accepted_wide <- tidyr::spread(
data  = accepted[, c("iter", "unique", "value")],
key   = unique,
value = value)
return(long=accepted, wide=accepted_wide)}
booty <- bootstrap_ppmn(dag_model, test_df, nsim = 30000)
PerformanceAnalytics::chart.Correlation(accepted_wide)
booty <- bootstrap_ppmn(dag_model, test_df, nsim = 15000)
bootstrap_ppmn <- function(object, new_data, nsim = 10000, quantile=0.01, interval_type = "CI") {
preds        <- vector("list", nsim)
bootstrap    <- vector("list", nsim)
distance     <- vector("numeric", nsim)
store_params <- vector("list", nsim)
for (b in 1:nsim) {
#print(b)
boot_data        <- new_data[sample(nrow(new_data), replace = TRUE), ]
preds            <- predict_ppmn(object, boot_data, nsim = 1, interval_type = interval_type)
rmse_df          <- preds$Data-do.call(cbind, lapply(preds$Variance[which(!names(preds$Variance) %in% preds$Roots)], function(x) x[[1]]))
distance[b]      <- sum(rowSums(log(abs(rmse_df)), na.rm=T), na.rm = T)
store_params[[b]]<- preds$Parameters}
accepted <- store_params[which(distance < quantile(distance, quantile))]
extract_param_df <- function(accepted) {
out <- lapply(seq_along(accepted), function(i) {
sample_i <- accepted[[i]]
# each node is sample_i$Chl, sample_i$DOC, etc.
nodes <- names(sample_i)
# for each node extract b0, b1, ...
node_df <- do.call(rbind, lapply(nodes, function(node) {
params <- sample_i[[node]][[1]]         # numeric vector with names b0, b1, ...
data.frame(
variable  = node,
parameter = names(params),
value     = as.numeric(params),
iter      = i
)
}))
node_df
})
do.call(rbind, out)
}
accepted <- extract_param_df(accepted)
accepted$unique <- paste0(accepted$variable, "_", accepted$parameter)
accepted_wide <- tidyr::spread(
data  = accepted[, c("iter", "unique", "value")],
key   = unique,
value = value)
return(long=accepted, wide=accepted_wide)}
booty <- bootstrap_ppmn(dag_model, test_df, nsim = 15000)
bootstrap_ppmn <- function(object, new_data, nsim = 10000, quantile=0.01, interval_type = "CI") {
preds        <- vector("list", nsim)
bootstrap    <- vector("list", nsim)
distance     <- vector("numeric", nsim)
store_params <- vector("list", nsim)
for (b in 1:nsim) {
#print(b)
boot_data        <- new_data[sample(nrow(new_data), replace = TRUE), ]
preds            <- predict_ppmn(object, boot_data, nsim = 1, interval_type = interval_type)
rmse_df          <- preds$Data-do.call(cbind, lapply(preds$Variance[which(!names(preds$Variance) %in% preds$Roots)], function(x) x[[1]]))
distance[b]      <- sum(rowSums(log(abs(rmse_df)), na.rm=T), na.rm = T)
store_params[[b]]<- preds$Parameters}
accepted <- store_params[which(distance < quantile(distance, quantile))]
extract_param_df <- function(accepted) {
out <- lapply(seq_along(accepted), function(i) {
sample_i <- accepted[[i]]
# each node is sample_i$Chl, sample_i$DOC, etc.
nodes <- names(sample_i)
# for each node extract b0, b1, ...
node_df <- do.call(rbind, lapply(nodes, function(node) {
params <- sample_i[[node]][[1]]         # numeric vector with names b0, b1, ...
data.frame(
variable  = node,
parameter = names(params),
value     = as.numeric(params),
iter      = i
)
}))
node_df
})
do.call(rbind, out)
}
accepted <- extract_param_df(accepted)
accepted$unique <- paste0(accepted$variable, "_", accepted$parameter)
accepted_wide <- tidyr::spread(
data  = accepted[, c("iter", "unique", "value")],
key   = unique,
value = value)
return(list(long=accepted, wide=accepted_wide))}
booty <- bootstrap_ppmn(dag_model, test_df, nsim = 15000)
test_df <- read_excel("C:/Users/admin/OneDrive/Bureaublad/PPMN/Test dataset/Test.xlsx")
colnames(test_df)[8:ncol(test_df)] <- c("Chl", "DOC", "pH", "TP", "EC", "Temp",  "DO", "Alk", "HCO3", "Macrophytes")
new_data <- test_df
table(new_data$Nr.)
table(c(new_data$Nr.,NA))
any(c(new_data$Nr.,NA))
any(c(new_data$Nr.,NA))
strata=test_df$Nr.
if(!is.null(strata)){if(any(is.na(strata))){stop("no NA are allowed in strata")}}
strata
strata_prob <- table(strata)
strata_prob <- prop.table(table(strata))
strata_prob
1-strata_prob
strata_prob <- 1-prop.table(table(strata))
strata_prob
strata_prob <- table(strata)
strata_prob
strata_prob
split_df <- split(new_data$Nr.)
split_df <- split(new_data, new_data$Nr.)
strata_number <- min(table(strata))
strata_number <- min(table(strata))
split_df <- split(new_data, new_data$Nr.)
lapply(split_df, function(x) x[sample(strata_number, replace = T)])
strata_df <- lapply(split_df, function(x) x[sample(strata_number, replace = T)])
strata_df <- do.call(rbind, strata_df)
View(strata_df)
strata_number
strata_number <- min(table(strata))
split_df <- split(new_data, new_data$Nr.)
strata_df <- lapply(split_df, function(x) x[sample(1:nrow(x), size = strata_number, replace = T)])
new_data <- test_df
split_df <- split(new_data, new_data$Nr.)
strata_df <- lapply(split_df, function(x) x[sample(1:nrow(x), size = strata_number, replace = T)])
strata_number
View(split_df)
strata_df <- lapply(split_df, function(x) x[sample(1:nrow(x), size = strata_number, replace = T),])
strata_df <- do.call(rbind, strata_df)
rowMeans(strata_df)
names(dag_model$Parameters)
names(dag_model$`Parameter table`$dependent)
dag_model$`Parameter table`$dependent
uniqe(dag_model$`Parameter table`$dependent)
unique(dag_model$`Parameter table`$dependent)
strata_df[unique(dag_model$`Parameter table`$dependent)]
bootstrap_ppmn <- function(object, new_data, strata=NULL, nsim = 10000, quantile=0.01, interval_type = "CI") {
preds        <- vector("list", nsim)
bootstrap    <- vector("list", nsim)
distance     <- vector("numeric", nsim)
store_params <- vector("list", nsim)
if(!is.null(strata)){if(any(is.na(strata))){stop("no NA are allowed in strata")}}
strata_number <- min(table(strata))
split_df <- split(new_data, new_data$Nr.)
for (b in 1:nsim) {
print(b)
if(!is.null(strata)){
strata_df <- lapply(split_df, function(x) x[sample(1:nrow(x), size = strata_number, replace = T),])
boot_data <- do.call(rbind, strata_df)
}else{
boot_data        <- new_data[sample(nrow(new_data), replace = TRUE), ]
}
preds            <- predict_ppmn(object, boot_data, nsim = 1, interval_type = interval_type)
rmse_df          <- preds$Data-do.call(cbind, lapply(preds$Variance[which(!names(preds$Variance) %in% preds$Roots)], function(x) x[[1]]))
distance[b]      <- sum(rowSums(log(abs(rmse_df)), na.rm=T), na.rm = T)
store_params[[b]]<- preds$Parameters}
accepted <- store_params[which(distance < quantile(distance, quantile))]
extract_param_df <- function(accepted) {
out <- lapply(seq_along(accepted), function(i) {
sample_i <- accepted[[i]]
# each node is sample_i$Chl, sample_i$DOC, etc.
nodes <- names(sample_i)
# for each node extract b0, b1, ...
node_df <- do.call(rbind, lapply(nodes, function(node) {
params <- sample_i[[node]][[1]]         # numeric vector with names b0, b1, ...
data.frame(
variable  = node,
parameter = names(params),
value     = as.numeric(params),
iter      = i
)
}))
node_df
})
do.call(rbind, out)
}
accepted <- extract_param_df(accepted)
accepted$unique <- paste0(accepted$variable, "_", accepted$parameter)
accepted_wide <- tidyr::spread(
data  = accepted[, c("iter", "unique", "value")],
key   = unique,
value = value)
return(list(long=accepted, wide=accepted_wide))}
booty <- bootstrap_ppmn(dag_model, test_df, strata = test_df$Nr., nsim = 15000)
PerformanceAnalytics::chart.Correlation(booty$wide)
PerformanceAnalytics::chart.Correlation(booty$wide[,-1])
cor(booty$wide)
as.data.frame(cor(booty$wide))
cormat <- cor(booty$wide)
flattenCorrMatrix <- function(cormat, pmat) {
ut <- upper.tri(cormat)
data.frame(
row = rownames(cormat)[row(cormat)[ut]],
column = rownames(cormat)[col(cormat)[ut]],
cor  =(cormat)[ut],
p = pmat[ut]
)
}
flattenCorrMatrix <- function(cormat) {
ut <- upper.tri(cormat)
data.frame(
row = rownames(cormat)[row(cormat)[ut]],
column = rownames(cormat)[col(cormat)[ut]],
cor  =(cormat)[ut]
)
}
flattenCorrMatrix(cormat)
yep <- flattenCorrMatrix(cormat)
abs(yep$cor)>0.1
[abs(yep$cor)>0.1]
yep[abs(yep$cor)>0.1,]
yep <- yep[abs(yep$cor)>0.1,]
c(yep$row, yep$column)
unique(c(yep$row, yep$column))
View(booty)
cormat <- cor(booty$wide[,-1])
flattenCorrMatrix <- function(cormat) {
ut <- upper.tri(cormat)
data.frame(
row = rownames(cormat)[row(cormat)[ut]],
column = rownames(cormat)[col(cormat)[ut]],
cor  =(cormat)[ut]
)
}
yep <- flattenCorrMatrix(cormat)
yep <- yep[abs(yep$cor)>0.1,]
unique(c(yep$row, yep$column))
sub_booty <- booty[unique(c(yep$row, yep$column))]
PerformanceAnalytics::chart.Correlation(sub_booty)
View(sub_booty)
cormat <- cor(booty$wide[,-1])
flattenCorrMatrix <- function(cormat) {
ut <- upper.tri(cormat)
data.frame(
row = rownames(cormat)[row(cormat)[ut]],
column = rownames(cormat)[col(cormat)[ut]],
cor  =(cormat)[ut]
)
}
yep <- flattenCorrMatrix(cormat)
yep <- yep[abs(yep$cor)>0.1,]
sub_booty <- booty$wide[unique(c(yep$row, yep$column))]
PerformanceAnalytics::chart.Correlation(sub_booty)
0.2^2
cormat <- cor(booty$wide[,-1])
flattenCorrMatrix <- function(cormat) {
ut <- upper.tri(cormat)
data.frame(
row = rownames(cormat)[row(cormat)[ut]],
column = rownames(cormat)[col(cormat)[ut]],
cor  =(cormat)[ut]
)
}
yep <- flattenCorrMatrix(cormat)
yep <- yep[abs(yep$cor)>0.2,]
sub_booty <- booty$wide[unique(c(yep$row, yep$column))]
PerformanceAnalytics::chart.Correlation(sub_booty)
warnings()
chart.Correlation.nostars <- function (R, histogram = TRUE, method = c("pearson", "kendall",
"spearman"), ...)
{
x = checkData(R, method = "matrix")
if (missing(method))
method = method[1]
panel.cor <- function(x, y, digits = 2, prefix = "",
use = "pairwise.complete.obs", method = "pearson",
cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- cor(x, y, use = use, method = method)
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste(prefix, txt, sep = "")
if (missing(cex.cor))
cex <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex * (abs(r) + 0.3)/1.3)
}
hist.panel = function(x, ... = NULL) {
par(new = TRUE)
hist(x, col = "light gray", probability = TRUE,
axes = FALSE, main = "", breaks = "FD")
lines(density(x, na.rm = TRUE), col = "red", lwd = 1)
rug(x)
}
# NEW: linear regression panel
panel.lm <- function(x, y, ...) {
points(x, y, pch = 20, col = rgb(0,0,0,0.4))
abline(lm(y ~ x), col = "red", lwd = 2)
}
if (histogram)
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor,
diag.panel = hist.panel)
else
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor)
}
chart.Correlation.nostars(sub_booty)
chart.Correlation.nostars <- function (R, histogram = TRUE, method = c("pearson", "kendall",
"spearman"), ...)
{
if (missing(method))
method = method[1]
panel.cor <- function(x, y, digits = 2, prefix = "",
use = "pairwise.complete.obs", method = "pearson",
cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- cor(x, y, use = use, method = method)
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste(prefix, txt, sep = "")
if (missing(cex.cor))
cex <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex * (abs(r) + 0.3)/1.3)
}
hist.panel = function(x, ... = NULL) {
par(new = TRUE)
hist(x, col = "light gray", probability = TRUE,
axes = FALSE, main = "", breaks = "FD")
lines(density(x, na.rm = TRUE), col = "red", lwd = 1)
rug(x)
}
# NEW: linear regression panel
panel.lm <- function(x, y, ...) {
points(x, y, pch = 20, col = rgb(0,0,0,0.4))
abline(lm(y ~ x), col = "red", lwd = 2)
}
if (histogram)
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor,
diag.panel = hist.panel)
else
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor)
}
chart.Correlation.nostars(sub_booty)
chart.Correlation.nostars <- function (x, histogram = TRUE, method = c("pearson", "kendall",
"spearman"), ...)
{
if (missing(method))
method = method[1]
panel.cor <- function(x, y, digits = 2, prefix = "",
use = "pairwise.complete.obs", method = "pearson",
cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- cor(x, y, use = use, method = method)
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste(prefix, txt, sep = "")
if (missing(cex.cor))
cex <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex * (abs(r) + 0.3)/1.3)
}
hist.panel = function(x, ... = NULL) {
par(new = TRUE)
hist(x, col = "light gray", probability = TRUE,
axes = FALSE, main = "", breaks = "FD")
lines(density(x, na.rm = TRUE), col = "red", lwd = 1)
rug(x)
}
# NEW: linear regression panel
panel.lm <- function(x, y, ...) {
points(x, y, pch = 20, col = rgb(0,0,0,0.4))
abline(lm(y ~ x), col = "red", lwd = 2)
}
if (histogram)
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor,
diag.panel = hist.panel)
else
pairs(x, gap = 0, lower.panel = panel.lm, upper.panel = panel.cor)
}
chart.Correlation.nostars(sub_booty)
0.3^2
0.36^2
0.31^2
0.32^2
sqrt(0.3)
sqrt(0.1)
yep <- flattenCorrMatrix(cormat)
yep <- yep[abs(yep$cor)>0.3162278,]
sub_booty <- booty$wide[unique(c(yep$row, yep$column))]
chart.Correlation.nostars(sub_booty)

corpus <- VCorpus(VectorSource(sentences_vec))
corpus <- tm_map(corpus, content_transformer(tolower))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, removeNumbers)
corpus <- tm_map(corpus, stripWhitespace)
corpus <- tm_map(corpus, removeWords, stopwords("en"))  # optional
dtm_pred <- DocumentTermMatrix(corpus)
dtm_bin_pred <- as.data.frame(as.matrix(dtm_pred))
dtm_bin_pred[dtm_bin_pred > 0] <- 1   # convert counts to binary presence/absence
pred_data <- dtm_bin_pred[colnames(dtm_bin)[colnames(dtm_bin) %in% colnames(dtm_bin_pred)],]
!colnames(pred_data) %in% colnames(dtm_bin_pred)
pred_data[!colnames(pred_data) %in% colnames(dtm_bin_pred)]
colnames(pred_data)[!colnames(pred_data) %in% colnames(dtm_bin_pred)]
colnames(pred_data)[!colnames(dtm_bin_pred) %in% colnames(pred_data)]
citation()
citation("ggplot2")
library(igraph)
library(ggraph)
library(readxl)
library(EcoPostView)
library(ggplot2)
data <- read_excel("C:/Users/admin/OneDrive/Bureaublad/Book2.xlsx", sheet=1)
formula=list(c(fun="sigmoidal", edge="Chl~TP", trans="log",
prior_mu_b0=c(600, 300), prior_se_b0=c(100, 50), trunc_a_b0=0,
trunc_a_b2=0),
c(fun="sigmoidal", edge="Chl~TN", trans="log",
prior_mu_b0=c(600, 300), prior_se_b0=c(100, 50), trunc_a_b0=0,
trunc_a_b2=0),
c(fun="log", edge="Macrophytes~Chl+Temp", trans="log",
prior_mu_b0=2.5, prior_se_b0=0.2,
prior_mu_b1=-0.3, prior_se_b1=0.15, trunc_b_b1=0),
c(fun="log", edge="Invertebrates~Macrophytes", trans="log",
prior_mu_b1=0.3, prior_se_b1=0.15),
c(fun="log", edge="OCGET~Macrophytes", trans="log",
prior_mu_b1=0.5, prior_se_b1=0.25),
c(fun="class", edge="Characeae~Chl",
prior_mu_b0=5, prior_se_b0=5, trunc_a_b0=0,
prior_mu_b1=5, prior_se_b1=5, trunc_a_b1=0,
prior_se_b2=50, prior_se_b2=100, trunc_a_b2=0,
prior_mu_b4=0.4, prior_se_b4=0.05, trunc_a_b4=0, trunc_b_b4=1),
c(fun="sigmoidal", edge="pH~Chl",
prior_mu_b0=10, prior_se_b0=1.5, trunc_a_b0=6, trunc_a_b2=0),
c(fun="sigmoidal", edge="CO2~pH",
prior_mu_b0=60, prior_se_b0=30, trunc_a_b0=0,
prior_mu_b1=6, prior_se_b1=2,
prior_mu_b2=-0.5, prior_se_b2=1,  trunc_b_b2=0),
c(fun="sigmoidal", edge="HCO3~pH",
prior_mu_b0=150, prior_se_b0=50, trunc_a_b0=0,
prior_mu_b1=c(10.4, 9), prior_se_b1=c(1, 1), trunc_a_b1=0, trunc_b_b1=14,
prior_mu_b2=0.5, prior_se_b2=1, trunc_a_b2=0),
c(fun="identity", edge="DOC~Chl", trans="log",
prior_mu_b0=10, prior_se_b0=5,
prior_mu_b1=1, prior_se_b1=0.5),
c(fun="sigmoidal",  trans="log", edge="O2~DOC",
prior_mu_b0=14, prior_se_b0=2,
prior_mu_b2=-1, prior_se_b2=0.5),
c(fun="log",  trans="log", edge="O2~Temp",
prior_mu_b0=14, prior_se_b0=2,
prior_mu_b1=-0.25, prior_se_b1=0.125))
input_values    <- list(TP = seq(1, 150, length.out=200),
TN = seq(1, 30, length.out=200),
Temp = seq(4, 30, length.out=200))
n_grid=200
nsim=3000
nsim=3000
interval_type="CI"
node_size=16
arrow_size=3
arrow_offset=5.5
layout_type="auto"
#Check if input_values is of the same length
lengths <- unlist(lapply(input_values, length))
if(!all(lengths %in% lengths[1])){stop("input_values are not of the same length.")}
#Check the formulas for "~".
e_name <- sapply(formula, function(x) x["edge"])
if(!all(grepl("~", e_name))){ stop("no ~ detected in at least one formula.")}
#Check if the correct edge functions are given
e_fun <- sapply(formula, function(x) x["fun"])
if (!all(e_fun %in% c('identity', 'log', 'logit', 'sigmoidal', 'class'))){
stop("Not the correct edge function given in data set, it should be identity, log, logit or sigmoidal")}
#match edge formula with the provided data
matches        <- lapply(formula, function(x){
edge_formula <- gsub(" ", "", x["edge"])
edge_data    <- gsub(" ", "", data$edge)
which(data$`function` == x["fun"] & edge_data == edge_formula)})
#Check if input_values is of the same length
lengths <- unlist(lapply(input_values, length))
if(!all(lengths %in% lengths[1])){stop("input_values are not of the same length.")}
#Check the formulas for "~".
e_name <- sapply(formula, function(x) x["edge"])
if(!all(grepl("~", e_name))){ stop("no ~ detected in at least one formula.")}
#Check if the correct edge functions are given
e_fun <- sapply(formula, function(x) x["fun"])
if (!all(e_fun %in% c('identity', 'log', 'logit', 'sigmoidal', 'class'))){
stop("Not the correct edge function given in data set, it should be identity, log, logit or sigmoidal")}
#match edge formula with the provided data
matches        <- lapply(formula, function(x){
edge_formula <- gsub(" ", "", x["edge"])
edge_data    <- gsub(" ", "", data$edge)
which(data$`function` == x["fun"] & edge_data == edge_formula)})
data <- read_excel("C:/Users/admin/OneDrive/Bureaublad/Book2.xlsx", sheet=1)
#Check if input_values is of the same length
lengths <- unlist(lapply(input_values, length))
if(!all(lengths %in% lengths[1])){stop("input_values are not of the same length.")}
#Check the formulas for "~".
e_name <- sapply(formula, function(x) x["edge"])
if(!all(grepl("~", e_name))){ stop("no ~ detected in at least one formula.")}
#Check if the correct edge functions are given
e_fun <- sapply(formula, function(x) x["fun"])
if (!all(e_fun %in% c('identity', 'log', 'logit', 'sigmoidal', 'class'))){
stop("Not the correct edge function given in data set, it should be identity, log, logit or sigmoidal")}
#match edge formula with the provided data
matches        <- lapply(formula, function(x){
edge_formula <- gsub(" ", "", x["edge"])
edge_data    <- gsub(" ", "", data$edge)
which(data$`function` == x["fun"] & edge_data == edge_formula)})
#Check if if there is a mismatch between equations in the formula and data
if(any(unlist(lapply(matches, function(x) length(x) == 0)))){
stop(paste0("Edge name(s): ",sapply(formula[unlist(lapply(matches, function(x) length(x) == 0))], function(f) f["edge"]), ", or function(s): ", sapply(formula[unlist(lapply(matches, function(x) length(x) == 0))], function(f) f["fun"]), ", are different between the formula and data provided."))}
#Estimate model parameters
param_est      <- list()
for(i in 1:length(matches)){
#For each edge match sub divide the data and split per parameter b0, b1 and b2
sub_df       <- data[matches[[i]],]
split_df     <- split(sub_df, sub_df$parameter)
#Extract edge function and the name of the edge
edge_fun <- formula[[i]]["fun"]
edge     <- formula[[i]]["edge"]
#Select the priors based on the names
priors        <- formula[[i]][grepl("prior", names(formula[[i]]))]
#Select the truncations based on the names
truncation    <- formula[[i]][grepl("trunc", names(formula[[i]]))]
#Number of independent vars for linear model
length_iv     <- length(unlist(strsplit(unlist(strsplit(edge, "\\~"))[2], "\\+")))
#Generate minimal a list of possible prior names and truncations
if(any(c('identity', 'log', 'logit') %in% edge_fun)){
pos_par       <- paste0(c("mu_b", "se_b"), rep(seq(0, length_iv, 1), each=2))
pos_trunc     <- paste0(c("a_b", "b_b"), rep(seq(0, length_iv, 1), each=2))
}else if(c('class') %in% edge_fun){
pos_par       <- c("mu_b0", "se_b0", "mu_b1", "se_b1", "mu_b2", "se_b2", "mu_b3", "se_b3", "mu_b4", "se_b4")
pos_trunc     <- c("a_b0", "b_b0", "a_b1", "b_b1", "a_b2", "b_b2", "a_b3", "b_b3", "a_b4", "b_b4")
}else{
pos_par       <- c("mu_b0", "se_b0", "mu_b1", "se_b1", "mu_b2", "se_b2")
pos_trunc     <- c("a_b0", "b_b0", "a_b1", "b_b1", "a_b2", "b_b2")}
#Based on the possible prior names select the given prior. If no prior is given set prior to mu=0 and se=1000.
select_prior       <- lapply(pos_par, function(pattern) {
selection   <- as.numeric(priors[grepl(pattern, names(priors))])
if (length(selection) == 0) {
if (grepl("mu", pattern)) {return(0)
} else if (grepl("se", pattern)) { return(1000)}
} else {
return(selection)
}})
#Select possible truncations
select_truncation  <- lapply(pos_trunc, function(pattern) {
selection   <- as.numeric(truncation[grepl(pattern, names(truncation))])
if (length(selection) == 0) {
if (grepl("a", pattern)) {return(-Inf)
} else if (grepl("b", pattern)) {return(Inf)}
} else {
return(selection)
}})
#Generate a list to store the estimations for the parameters of the edge function
total   <- list()
#For the number of parameter each has mu and se therefore generate a vector with
#an interval sequence of 2 this is the same for the truncatin a and b
seq_par <- seq(1, length(select_prior), by = 2)
for (j in 1:length(seq_par)) {
prior_mu    <- select_prior[[seq_par[j]]]
prior_mu_se <- select_prior[[seq_par[j] + 1]]
a_trunc     <- select_truncation[[seq_par[j]]]
b_trunc     <- select_truncation[[seq_par[j] + 1]]
if(j>length(split_df)){stop(sprintf("Not correct number of parameters given in the data for the edge %s with the function %s",
formula[[i]][2], formula[[i]][1]))}
total[[c("b0","b1","b2","b3","b4")[j]]]  <- abmeta(split_df[[j]]$estimate, split_df[[j]]$error, prior_mu, prior_mu_se, a=a_trunc, b=b_trunc, interval_type = interval_type)
}
param_est[[edge]] <- Filter(function(x) length(x) > 0, total)
}
#Expected value and variance of y E(y) Var(E(y))
expected_y     <- function(func, params, trans, x){
betas <- sapply(params, function(p) p["mu"])
if(is.na(trans)) {
x_t <- x
}else if(trans == "log"){
x_t <- log(x)
}else if (trans == "sqrt"){
x_t <- sqrt(x)
}else{
return(NA)}
if (is.na(func)){func <- "identity"}
if(func %in%  c("identity", "log", "logit")){
if(length(betas) == 1){stop("At least two parameters needed for a linear model: b0 and b1.")}
if (is.numeric(x_t) && is.null(dim(x_t))) {
eta <- betas[1] + betas[-1] * x_t
} else if (is.matrix(x_t)) {
eta <- betas[1] + drop(x_t %*% betas[-1])
} else {
stop("x must be a numeric vector or matrix.")
}}
if(func == "identity") {
eta
}else if (func == "log") {
exp(eta)
}else if (func == "logit") {
plogis(eta)
}else if (func == "sigmoidal") {
if (length(betas) != 3){stop("Three parameters needed for a sigmoidal model: b0, b1 and b2.")}
as.numeric(betas[1] / (1 + exp((betas[2] - x_t) / betas[3])))
} else if (func == "class") {
if (length(betas) != 5){stop("Five parameters needed for the Bayesian classifier: b0, b1, b2, b3 and b4.")}
log_num <- dnorm(x_t, betas[1], betas[2], log = TRUE)
log_den <- dnorm(x_t, betas[3], betas[4], log = TRUE)
log_likelihood <- log_num - log_den
as.numeric((exp(log_likelihood) * betas[5]) / ((exp(log_likelihood) * betas[5]) + (1 - betas[5])))
} else {
NA
}
}
variance_y     <- function(func, params, trans, input_value, nsim){
montecarlo <- function(func, params, trans, x){
betas <- sapply(params, function(p) truncnorm::rtruncnorm(1, mean = p["mu"], sd = p["se"], a = p["a"], b = p["b"]))
if(is.na(trans)) {
x_t <- x
}else if (trans == "log") {
x_t <- log(x)
}else if (trans == "sqrt") {
x_t <- sqrt(x)
}else {
return(NA) }
if (is.na(func)){func <- "identity"}
if (func %in% c("identity", "log", "logit")) {
if (length(betas) == 1){stop("At least two parameters needed for a linear model: b0 and b1.")}
if (is.numeric(x_t) && is.null(dim(x_t))) {
eta <- betas[1] + betas[-1] * x_t
} else if (is.matrix(x_t)) {
eta <- betas[1] + drop(x_t %*% betas[-1])
} else {
stop("x must be a numeric vector or matrix.")
}
}
if (func == "identity") {
eta
} else if (func == "log") {
exp(eta)
} else if (func == "logit") {
plogis(eta)
} else if (func == "sigmoidal") {
if (length(betas) != 3){stop("Three parameters needed for a sigmoidal model: b0, b1 and b2.")}
as.numeric(betas[1] / (1 + exp((betas[2] - x_t) / betas[3])))
} else if (func == "class") {
if (length(betas) != 5){stop("Four parameters needed for the Bayesian classifier: b0, b1, b2, b3 and b4.")}
log_num <- dnorm(x_t, betas[1], betas[2], log = TRUE)
log_den <- dnorm(x_t, betas[3], betas[4], log = TRUE)
log_likelihood <- log_num - log_den
as.numeric((exp(log_likelihood) * betas[5]) / ((exp(log_likelihood) * betas[5]) + (1 - betas[5])))
} else {
NA
}
}
results <- lapply(1:nsim, function(i){
montecarlo(func, params, trans, input_value)})
return(results)}
#DAG building function
build_dag <- function(formula) {
edges <- sapply(formula, function(x) x[["edge"]])
start_nodes <- sub("(.*)~", "", edges)   # LHS
end_nodes   <- sub("~(.*)", "", edges)   # RHS (can still contain +)
g_pred <- graph_from_edgelist(cbind(start_nodes, end_nodes), directed = TRUE)
vis_edges <- do.call(rbind, lapply(edges, function(e) {
parts <- strsplit(e, "~")[[1]]
dep <- parts[1]
indep <- strsplit(parts[2], "\\+")[[1]]
cbind(indep, dep)}))
g_vis <- graph_from_edgelist(vis_edges, directed = TRUE)
exec_edges <- do.call(rbind, lapply(edges, function(e) {
parts <- strsplit(e, "~")[[1]]
dep <- parts[1]
indep <- strsplit(parts[2], "\\+")[[1]]}))
g_exec <- graph_from_edgelist(exec_edges, directed = TRUE)
list(predict_dag = g_pred, visual_dag = g_vis, exec_dag = g_exec)
}
#Create DAG based on previous function
dag_info        <- build_dag(formula)
#Split in names of edges, dependent and independent vars
split_edges       <- strsplit(e_name, "\\~")
dependent_vars    <- sapply(split_edges, `[`, 1)
independent_vars  <- unlist(strsplit(sapply(split_edges, `[`, 2), "\\+"))
indepndent_vars   <- unique(independent_vars)
#True roots are independent vars never appearing as dependent
true_roots <- setdiff(unique(independent_vars), unique(dependent_vars))
#Check input_values only against true roots
missing_inputs <- setdiff(true_roots, names(input_values))
if(length(missing_inputs) > 0){
stop(paste0("The variable(s): ", paste(missing_inputs, collapse=", ")," is/are not given in the input."))}
#Function to compute predictions in DAG order
compute_dag_predictions <- function(dag_info, param_est, input_values, n_grid, nsim = 3000){
g     <- dag_info$predict_dag$graph
funcs <- dag_info$predict_dag$functions
trans <- dag_info$predict_dag$transformations
# helper: find predictive edges for a node given its parents
find_predict_edges <- function(node, parent_nodes, funcs) {
combined <- paste0(node, "~", paste(parent_nodes, collapse = "+"))
if (combined %in% names(funcs)) {
return(list(edge_names = combined, is_additive = TRUE))
}
per_edges <- paste0(node, "~", parent_nodes)
present_per <- per_edges[per_edges %in% names(funcs)]
if (length(present_per) > 0) {
return(list(edge_names = present_per, is_additive = FALSE))
}
matches <- names(funcs)[sapply(names(funcs), function(e) strsplit(e, "~")[[1]][1] == node)]
if (length(matches) > 0) {
comb_idx <- which(grepl("\\+", matches))
if (length(comb_idx) > 0) {
return(list(edge_names = matches[comb_idx[1]], is_additive = TRUE))
}
return(list(edge_names = matches, is_additive = FALSE))
}
return(list(edge_names = NA_character_, is_additive = NA))
}
# Initialize prediction lists
predictions_expected <- list()
predictions_variance <- list()
root_nodes <- names(input_values)
for (root in root_nodes) {
predictions_expected[[root]] <- input_values[[root]]
predictions_variance[[root]] <- input_values[[root]]
}
topo_order <- topo_sort(g, mode = "out")
# Helper for variance calculation
combine_parent_list <- function(parent_list) {
nsim <- length(parent_list[[1]])
n <- length(parent_list[[1]][[1]])
np <- length(parent_list)
arr <- array(NA, dim = c(n, np, nsim))
for (p in seq_along(parent_list)) {
for (s in 1:nsim) {
arr[, p, s] <- parent_list[[p]][[s]]
}
}
arr
}
normalize_parent <- function(x, nsim = nsim) {
if (is.list(x)) {
return(x)
} else if (is.numeric(x) && length(x) == length(input_values[[1]])) {
return(replicate(nsim, x, simplify = FALSE))
} else {
stop("Unknown parent type")
}
}
for (i in topo_order) {
node <- V(g)$name[i]
node <- unlist(strsplit(node, "\\+"))
if (any(node %in% root_nodes)) next
parents <- V(g)$name[neighbors(g, node, mode = "in")]
parent_nodes <- unlist(strsplit(parents, "\\+"))
# Find predictive edges and additivity
edge_res <- find_predict_edges(node, parent_nodes, funcs)
edge_names <- edge_res$edge_names
is_additive <- edge_res$is_additive
if (is.na(edge_names[1])) {
warning("No predictive formula found for ", node, " with parents: ", paste(parent_nodes, collapse = ", "))
next
}
# Prepare input_expected matrix
input_expected <- do.call(cbind, predictions_expected[parent_nodes])
parent_list <- lapply(predictions_variance[parent_nodes], normalize_parent, nsim = nsim)
df_list <- lapply(seq_len(nsim), function(i) { do.call(cbind, lapply(parent_list, function(parent) parent[[i]])) })
### Expected value
if (is_additive) {
edge_func  <- funcs[[edge_names]]
edge_trans <- trans[[edge_names]]
params     <- param_est[[edge_names]]
predictions_expected[[node]] <- expected_y(edge_func, params, edge_trans, input_expected)
} else if (length(edge_names) > 1) {
# model averaging across multiple single-parent edges
preds <- lapply(edge_names, function(en) {
parent_of_en <- strsplit(en, "~")[[1]][2]
col_idx <- which(parent_nodes == parent_of_en)
ef <- funcs[[en]]
et <- trans[[en]]
par <- param_est[[en]]
expected_y(ef, par, et, input_expected[, col_idx])
})
predictions_expected[[node]] <- rowMeans(do.call(cbind, preds))
} else {
# single single-parent edge
ef <- funcs[[edge_names]]
et <- trans[[edge_names]]
par <- param_est[[edge_names]]
predictions_expected[[node]] <- expected_y(ef, par, et, input_expected)
}
### Variance
if (is_additive) {
predictions_variance[[node]] <- lapply(df_list, function(mat) {
res <- variance_y(func = edge_func, params = params, trans = edge_trans, input_value = mat, nsim = 1)
res[[1]]
})
} else if (length(edge_names) > 1) {
# model averaging for variance
result <- lapply(edge_names, function(en) {
parent_of_en <- strsplit(en, "~")[[1]][2]
col_idx <- which(parent_nodes == parent_of_en)
lapply(df_list, function(mat) {
variance_y(funcs[[en]], param_est[[en]], trans[[en]], mat[, col_idx], nsim = 1)
})
})
nsim_local <- length(result[[1]])
nmodels <- length(result)
collapsed <- vector("list", nsim_local)
for (ii in 1:nsim_local) {
mats <- lapply(result, `[[`, ii)
collapsed[[ii]] <- rowMeans(do.call(cbind, lapply(mats, `[[`, 1)))
}
predictions_variance[[node]] <- collapsed
} else {
# single single-parent variance
predictions_variance[[node]] <- lapply(df_list, function(mat) {
res <- variance_y(func = ef, params = par, trans = et, input_value = mat, nsim = 1)
res[[1]]
})
}
}
return(list(predictions = list(expected = predictions_expected, variance = predictions_variance),
root = input_values))
}
g_vis        <- dag_info$visual_dag$graph
visual_edges <- dag_info$visual_dag$edges
plot(g_vis)
dev.off()
dev.off()
plot(g_vis)
g_vis
g_vis        <- dag_info$visual_dag
plot(g_vis)
dag_info$visual_dag$edges
visual_edges <- dag_info$visual_dag
igraph::edge(g_vis)
dag_info$exec_dag
plot(dag_info$exec_dag)
#Build a full parameter table
par_tab <- lapply(seq_along(param_est), function(i) {
sub <- param_est[[i]]
indep <- strsplit(independent_vars[i], "\\+")[[1]]
if (e_fun[[i]] %in% c("sigmoidal", "class")) {
indep <- NA
} else {
indep <- NA
}
cbind(
edge = names(param_est)[i],
`edge function` = e_fun[i],
dependent = dependent_vars[i],
independent = indep,
do.call(rbind, sub)
)
})
par_tab
#Combine small table into one
full_table <- do.call(rbind, par_tab)
full_table
View(full_table)
full_table
full_table
rownames(full_table)
View(full_table)
i=1
sub <- param_est[[i]]
indep <- strsplit(independent_vars[i], "\\+")[[1]]
if (e_fun[[i]] %in% c("sigmoidal", "class")) {
indep <- NA
} else {
indep <- NA
}
names(param_est)[i]
names(param_est)
param_est[i]
names(param_est[i])
param_est[i]
param_est[[i]]
names(param_est[[i]])
cbind(
edge = names(param_est)[i],
`edge function` = e_fun[i],
dependent = dependent_vars[i],
independent = indep,
do.call(rbind, sub)
)
#Build a full parameter table
par_tab <- lapply(seq_along(param_est), function(i) {
sub <- param_est[[i]]
indep <- strsplit(independent_vars[i], "\\+")[[1]]
if (e_fun[[i]] %in% c("sigmoidal", "class")) {
indep <- NA
} else {
indep <- NA
}
cbind(
edge = names(param_est)[i],
`edge function` = e_fun[i],
dependent = dependent_vars[i],
independent = indep,
parameter = names(param_est[[i]]),
do.call(rbind, sub)
)
})
#Combine small table into one
full_table <- do.call(rbind, par_tab)
rownames(full_table)
rownames(full_table) <- NULL
View(full_table)

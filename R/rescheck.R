#' Residual check
#'
#' @param object An object generated by the meta function
#' @param order_predictor The order of the predictors
#' @param order_group The order of the groups
#' @param interval the interval for the descriptors
#' @param xlimit the upper quantile limit of 1/se or 1/n
#' @param ylimit The quantile limits residuals displayed in the figures
#' @param b0_out Display the intercept in the residuals, by default False
#'
#' @description
#' This function can be used to asses the bias of the model output. It is a visual ('eye balling') check
#' for the distribution of the residuals. The residuals should be approximately 'randomly' distributed around 0 (x-axis)
#' Compared to the inverse of the sample size (1/n) or inverse of the standard error (1/se). It is akin to classical funnel plots
#' The dashed red lines in the figures are only a reference, they do not present a direct meaning full interpretation to the bias.
#' Hence, if the 'effect-sizes' or parameter estimates are not standardized or are not elasticity coefficients the variance of the
#' residuals is not as well behaved and points fall easy outside of these dashed lines. For 1/se the dashed lines represent the
#' standard error around 0 at the interval level (default 0.931).For 1/n the dashed lines represent the standard error if the
#' standard deviation would be 1. In simple terms for both plot(1/se, se*z) and plot(1/n, 1/sqrt(n)). If an obvious bias would be
#' present a diagonal pattern would become visible the points would then not follow the solid vertical line at 0.
#'
#' @export
rescheck <- function(object, order_predictor = NULL, order_group = NULL, interval=0.931,
                     xlimit=0.9931, ylimit=c(0.0345, 0.9655), b0_out=T){

#extract levels
levels <- setNames(do.call(rbind.data.frame, strsplit(as.character(object$model$Data$level), "_")), c("parameter", "predictor", "link_function", "group"))

#If sample size is included
if(!is.null(object$model$Data$Nsamp)){
  df_resid  <- data.frame(resid=object$Residuals, n=object$model$Data$Nsamp, se=object$model$Data$se, levels)}else{
  df_resid  <- data.frame(resid=object$Residuals, se=object$model$Data$se, levels)}

#Only display residuals for b1 and do not include b0
if(b0_out==T){
df_resid                                       <- df_resid[df_resid$parameter != "b0",]}else{
df_resid$predictor[df_resid$predictor == "NA"] <- "b0 (Intercept)"
order_predictor                                <- c(order_predictor, "b0 (Intercept)")}

#order per group and predictor
if(!is.null(order_group)&&!is.null(order_group)){
  df_resid$group     <- factor(df_resid$group, levels = order_group)
  df_resid$predictor <- factor(df_resid$predictor, levels = order_predictor)
  df_resid           <- df_resid[order(df_resid$group, df_resid$predictor),]
}else if(!is.null(order_group)&&is.null(order_predictor)){
  df_resid$group     <- factor(df_resid$group, levels = order_group)
  df_resid$predictor <- factor(df_resid$predictor, levels = levels(df_resid$predictor))
  df_resid           <- df_resid[order(df_resid$group),]
}else if(!is.null(order_predictor)&&is.null(order_group)){
  df_resid$group     <- factor(df_resid$group, levels = levels(df_resid$group))
  df_resid$predictor <- factor(df_resid$predictor, levels = order_predictor)
  df_resid           <- df_resid[order(df_resid$predictor),]
}else{
  df_resid$group     <- factor(df_resid$group, levels = unique(df_resid$group))
  df_resid$predictor <- factor(df_resid$predictor, levels = unique(df_resid$predictor))
  df_resid           <- df_resid[order(df_resid$group, df_resid$predictor),]}

#Set limits for the base  plots
ylim_plot <- quantile(df_resid$resid, c(ylimit[1], ylimit[2]))
xlim_plot <- c(0, quantile(df_resid$resid, xlimit))

#Draw interval bounds for visual inspection
zval      <- qnorm(1 - (1 - interval)/2)
n_vals    <- seq(1, 1000, 1)
se_vals   <- seq(0.0001, max(abs(xlim_plot)), length.out=length(n_vals))

#Combine all interval bounds to plot
if(!is.null(object$model$Data$Nsamp)){
bounds <- data.frame(n_vals=1/n_vals,
                     se_vals=1/se_vals,
                     n_bounds=c(-1*(1/sqrt(n_vals))*zval, ul=(1/sqrt(n_vals))*zval),
                     se_bounds=c(-se_vals*zval, se_vals*zval),
                     g=rep(c("ll", "ul"), each=length(n_vals)))

#Plot interval bounds for sample size for all samples
plot_1_1 <- ggplot(df_resid, aes(1/n, resid))+xlab("Inverse sample size (1/n)")+ylab("Posterior mean model residuals")+
    geom_point(alpha=0.3, col="grey20")+xlim(0, 0.2)+ylim(ylim_plot[1], ylim_plot[2])+
    geom_line(data=bounds, aes(x=n_vals, y=n_bounds, group=g), inherit.aes = F, col="dodgerblue2", lty=2, lwd=1.2)+
    geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
    geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
    theme_classic()+
    theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

#Plot interval bounds for sample size per group
plot_1_2 <- ggplot(df_resid, aes(1/n, resid))+xlab("Inverse sample size (1/n)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+xlim(0, 0.2)+ylim(ylim_plot[1], ylim_plot[2])+
  geom_line(data=bounds, aes(x=n_vals, y=n_bounds, group=g), inherit.aes = F, col="dodgerblue2", lty=2, lwd=1.2)+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  facet_wrap(.~group)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

#Plot interval bounds for sample size per predictor
plot_1_3 <- ggplot(df_resid, aes(1/n, resid))+xlab("Inverse sample size (1/n)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+xlim(0, 0.2)+ylim(ylim_plot[1], ylim_plot[2])+
  geom_line(data=bounds, aes(x=n_vals, y=n_bounds, group=g), inherit.aes = F, col="dodgerblue2", lty=2, lwd=1.2)+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  facet_wrap(.~predictor)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))}

#Combine all interval bounds to plot without sample size
if(is.null(object$model$Data$Nsamp)){
bounds <- data.frame(se_vals=1/se_vals,
                     n_bounds=c(-1*sd(df_resid$resid)/sqrt(n_vals)*zval, ul=sd(df_resid$resid)/sqrt(n_vals)*zval))}

#plot interval bounds for standard error
plot_2_1 <- ggplot(df_resid, aes(1/se, resid))+xlab("Inverse standard error (1/se)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+
  xlim(0, xlim_plot[2])+ylim(ylim_plot[1], ylim_plot[2])+
  geom_line(data=bounds, aes(x=se_vals, y=se_bounds, group=g), inherit.aes = F, col="dodgerblue2", lty=2, lwd=1.2)+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

#plot interval bounds for standard error per group
plot_2_2 <- ggplot(df_resid, aes(1/se, resid))+xlab("Inverse standard error (1/se)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+
  xlim(0, xlim_plot[2])+ylim(ylim_plot[1], ylim_plot[2])+
  geom_line(data=bounds, aes(x=se_vals, y=se_bounds, group=g), inherit.aes = F, col="dodgerblue2", lty=2, lwd=1.2)+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  facet_wrap(.~group)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

#plot interval bounds for standard error per predictor
plot_2_3 <- ggplot(df_resid, aes(1/se, resid))+xlab("Inverse standard error (1/se)")+ylab("Posterior mean model residuals")+
  geom_point(alpha=0.3, col="grey20")+
  xlim(0, xlim_plot[2])+ylim(ylim_plot[1], ylim_plot[2])+
  geom_line(data=bounds, aes(x=se_vals, y=se_bounds, group=g), inherit.aes = F, col="dodgerblue2", lty=2, lwd=1.2)+
  geom_hline(yintercept = 0, lty=1, lwd=1.2,col="dodgerblue2")+
  geom_smooth(method = "lm", formula = 'y~x', se=F, col="tomato3", lty=2, lwd=1.2)+
  facet_wrap(.~predictor)+
  theme_classic()+
  theme(plot.margin = unit(c(.1, .1, .1, .1), "mm"))

#If sample size is included include all figs als with bias_n
if(!is.null(object$model$Data$Nsamp)){
  total <- list(bias_n=plot_1_1, bias_se=plot_2_1,
                bias_n_group=plot_1_2, bias_se_group=plot_2_2,
                bias_n_predictor=plot_1_3, bias_se_predictor=plot_2_3)}else{
  total <- list(bias_se=plot_2_1,
                bias_se_group=plot_2_2,
                bias_se_predictor=plot_2_3)}
return(total)}

